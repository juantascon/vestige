@comment Cognitive aspects of programming

@InProceedings{Peelle:1976,
  author       = {Howard A. Peelle},
  title        = {Learning mathematics with recursive computer
                  programs},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {116--130},
  year         = 1976,
  month        = feb,
  organization = {ACM \textsc{sigcse}}
}

@InProceedings{Jackson:1976,
  author       = {Glenn A. Jackson},
  title        = {A graphical technique for describing recursion},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {30--32},
  year         = 1976,
  month        = jul,
  organization = {ACM \textsc{sigcse}},
  abstract     = {One concept in computer science that is very
                  difficult for the beginner to grasp, and equally
                  difficult for the instructor to present in a
                  straight-forward understandable manner, is the
                  concept of recursion. Since this is a fundamental
                  concept through which the amount of computer code
                  required for some algorithms can be drastically
                  reduced, an instructor must discuss this area early
                  in a student's career, even though he runs the risk
                  of confusing a few students for a lecture or
                  two. This paper presents a method of describing
                  recursive procedure calls that utilizes a form of
                  self-generating state diagram. This approach enables
                  the student to visually keep track of where program
                  control is located at each moment during execution.}
}

@InProceedings{KahneyEisenstadt:1982,
  author    = {Hank Kahney and Marc Eisenstadt},
  title     = {Programmers' mental models of their programming
               tasks: {T}he interaction of real world knowledge and
               programming knowledge},
  booktitle = {Conf. of the Cognitive Science Society},
  pages     = {143--145},
  year      = 1982
}

@Article{KurlandPea:1985,
  author   = {D. Midian Kurland and Roy D. Pea},
  title    = {Children's mental models of recursive {L}ogo programs},
  journal  = {Educational Computing Research},
  year     = 1985,
  volume   = 1,
  number   = 2,
  abstract = {Children who had a year of Logo programming experience
              were asked to think aloud about what brief Logo
              recursive programs will do, and then to predict with
              a hand-simulation of the programs what the Logo
              graphics turtle will draw when the program is
              executed. If discrepancies arose in this last phase,
              children were asked to explain them. A prevalent but
              misguided "looping" interpretation of Logo recursion
              was identified, and this robust mental model
              persisted even in the face of contradiction between
              what the program did when executed and the child's
              predictions for what it would do.}
}

@Article{Pirolli:1986,
  author   = {Peter Pirolli},
  title    = {A cognitive model and computer tutor for programming
              recursion},
  journal  = {Human\hyp{}Computer Interaction},
  year     = 1986,
  volume   = 2,
  number   = 4,
  pages    = {319--355},
  month    = dec,
  note     = {{ISSN} 0737-0024},
  abstract = {This article discusses cognitive models of learning to
              program recursion and their relation to lessons on
              recursion in an intelligent computer tutor for LISP
              programming (the LISP Tutor). The cognitive models
              are implemented as production systems in which
              programming skill is characterized as the
              decomposition of programming goals into subgoals and
              elementary actions via the application of
              programming plans. Two sets of learning mechanisms
              are used in the cognitive models. Analogical
              problem-solving mechanisms use declarative knowledge
              of example program solutions to overcome
              problem-solving impasses. Knowledge compilation
              mechanisms summarize problem solutions into
              efficient problem-solving skill. Analyses and
              simulations of novice and expert programming were
              used to develop ideal models of the programming
              knowledge to confer upon students and bugs that
              characterize common misconceptions. The LISP Tutor
              uses the ideal models and bugs to guide its
              interactions with students. Experimental evaluations
              of the LISP Tutor indicate that it is more efficient
              and effective than classroom instruction.}
}

@InProceedings{BhuiyanGreerGordon:1989,
  author    = {Shawkat Bhuiyan and Jim E. Greer and Gordon I. McCalla},
  title     = {Mental models of recursion and their use in the
              {SCENT} programming advisor},
  booktitle = {Intl. Conf. on Knowledge Based Computer Systems},
  pages     = {135--144},
  year      = 1989,
  month     = dec,
  volume    = 444,
  series    = {LNCS},
  publisher = {Springer-Verlag, London, UK},
  note      = {{ISBN} 3-540-52850-4}
}

@InProceedings{LevyLapidotPaz:2001,
  author    = {Dalit Levy and Tami Lapidot and Tamar Paz},
  title     = {`{I}t's just like the whole picture, but smaller':
               {E}xpressions of gradualism, self\hyp{}similarity, and
               other pre-conceptions while classifying recursive
               phenomena},
  booktitle = {Workshop of the Psychology of Programming Interest Group},
  pages     = {249--262},
  year      = 2001,
  address   = {Bournemouth, UK},
  month     = apr,
  abstract  = {Recursion is a key concept, appearing in almost every
               introductory course in computer science. Educators
               and researchers often refer to difficulties in
               learning and teaching recursion. However, the
               research literature barely addresses the unique ways
               in which students relate to this interdisciplinary
               concept and the particular learners’language
               concerning recursive phenomena. The gap is most
               apparent when seen through a constructivist lens,
               where the students’prior knowledge and
               idiosyncratic conceptions are referred to and
               reflected upon in order to serve as a basis for
               further knowledge construction. In our study, high
               school students collaboratively classified several
               recursive phenomena and discussed their criteria and
               categories with each other. This paper focuses on a
               part of the study that deals with a variety of
               preconceptions which emerged from analysing the
               students’discourse, and suggests a model for
               organizing these preconceptions. Our findings could
               contribute to the recognition of the role of class
               discourse in the process of constructing the concept
               of recursion in particular, and in learning abstract
               computer science concepts in general.}
}

@InProceedings{GotschiSandersGalpin:2003,
  author       = {Tina Götschi and Ian Sanders and Vashti Galpin},
  title        = {Mental models of recursion},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {346--350},
  year         = 2003,
  month        = feb,
  address      = {Reno, Nevada, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-648-X},
  abstract     = {Recursion is a fundamental concept in Computer
                  Science. A student's knowledge of recursion can be
                  termed their mental model of recursion. A student's
                  mental model is viable if it allows them to
                  accurately and consistently represent the mechanics
                  of recursion. Non-viable mental models are
                  constructed if students have misconceptions about
                  the mechanisms of recursion or have misconceptions
                  about concepts fundamental to recursion. This paper
                  presents a study of the mental models of recursion
                  that first year students at the University of the
                  Witwatersrand have constructed in 2000, 2001 and
                  2002. It was found that while the majority of
                  students constructed the viable copies model, many
                  non-viable models such as the looping, active, step,
                  magic, return-value and various odd models were also
                  constructed. Identifying the models that students
                  have can allow lecturers to target individual
                  students' specific problems and analysis of the
                  models can provide insight into learning.}
}

@InProceedings{SandersGalpinGotschi:2006,
  author       = {Ian Sanders and Vashti Galpin and Tina Götschi},
  title        = {Mental models of recursion revisited},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {138--142},
  year         = 2006,
  month        = jun,
  address      = {Bologna, Italy},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-59593-055-8},
  abstract     = {Students struggle to understand recursion and we
                  need to find good ways to teach the concept. We
                  believe that an understanding of the mental models
                  of recursion that students develop will assist us in
                  teaching them more effectively. In 2003 we reported
                  on a study of the mental models our students
                  developed. This paper discusses some changes that we
                  made to our teaching in 2003 after that study. An
                  analysis of the students' mental models in 2003,
                  2004 and 2005 shows that more students are
                  developing the copies model of recursion which is
                  always a viable model.}
}

@TechReport{Gotschi:2003,
  author      = {Tina Götschi},
  title       = {Mental models of recursion},
  institution = {Faculty of Science, University of the Witwatersand},
  year        = 2003,
  address     = {Johannesburg, South Africa}
}

@InProceedings{Mirolo:2009,
  author       = {Claudio Mirolo},
  title        = {Mental models of recursive computations
                  vs. recursive analysis in the problem domain},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {397--397},
  year         = 2009,
  month        = jul,
  address      = {Paris, France},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 978-1-60558-381-5},
  abstract     = {The work outlined here was inspired by Ian Sanders,
                  Vashti Galpin and Tina Götschi, who analyze the
                  mental models of recursion by looking at how
                  students trace simple recursive
                  computations. Besides trying to understand if their
                  results generalize to a different context, I was
                  interested to see the correlations between the
                  mental models of the computation process and the
                  ability to establish recursive relationships in the
                  problem domain.  My investigation essentially lends
                  further support to their findings. However, a
                  consistent mental model of recursive computations,
                  although implied by the ability to use recursion in
                  problem-solving, does not seem to be sufficient for
                  the achievement of this higher-level skill.}
}

@InProceedings{SandersGalpin:2007,
  author       = {Ian Douglas Sanders and Vashti C. Galpin},
  title        = {Students' mental models of recursion at {W}its},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {317--317},
  year         = 2007,
  month        = jun,
  address      = {Dundee, Scotland},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 978-1-59593-610-3},
  abstract     = {Recursion is a concept which all computer scientists
                  should understand and be able to use but novices
                  find it difficult to master. In the School of
                  Computer Science at the University of the
                  Witwatersrand (Wits) we have for a long time been
                  concerned about how we can assist our students with
                  recursion. One thrust of our research is the study
                  of the mental models of recursion (c.f. Kahney)
                  which our first year students develop.}
}

@InProceedings{BhuiyanGreerGordon:1992,
  author    = {Shawkat Bhuiyan and Jim E. Greer and Gordon I. McCalla},
  title     = {Learning recursion through the use of a mental
               model-based programming environment},
  booktitle = {Intl. Conf. on Intelligent Tutoring Sys.},
  pages     = {50--57},
  year      = 1992,
  month     = jun,
  volume    = 608,
  series    = {LNCS},
  publisher = {Springer-Verlag, London, UK},
  note      = {{ISBN} 3-540-55606-0}
}

@Article{SinhaVessey:1992,
  author   = {Atish P. Sinha and Iris Vessey},
  title    = {Cognitive fit: {A}n empirical study of recursion and
              iteration},
  journal  = {IEEE Trans. on Soft. Eng.},
  year     = 1992,
  volume   = 18,
  number   = 5,
  pages    = {368--379},
  month    = may,
  note     = {{ISSN} 0098-5589},
  abstract = {A laboratory experiment was conducted to assess the
              basic theory and extensions to the theory for
              recursive tasks across programming languages. The
              experiment used 34 LISP and 48 Pascal computer
              science students in two repeated measures
              designs. Findings of the study are reported and
              analyzed. The results strongly suggest that
              investigation of programming constructs should take
              place in the context of specific programming
              languages. Since a number of languages provide
              similar kinds of programming constructs, it is
              difficult for programmers to choose those
              implementations that best suit their needs. One way
              of encouraging the use of desirable constructs would
              be to develop languages adapted to certain types of
              tasks. Such an approach would inherently lead to
              cognitive fit and the attendant performance benefits
              would be realized.}
}

@PhdThesis{Wu:1993,
  author   = {Cheng-Chih Wu},
  title    = {Conceptual models and individual cognitive learning
              styles in teaching recursion to novices},
  school   = {University of Texas},
  year     = 1993,
  address  = {Austin, Texas, USA},
  note     = {192 pages},
  abstract = {This study investigated how different types of
              conceptual models and cognitive learning styles
              influence novice programmers when learning
              recursion. A pretest-posttest, 2 X 2 (conceptual
              models X learning styles) factorial experimental
              design was implemented in order to study the
              problem. Two hundred thirty-seven students enrolled
              in an introductory computer science course at a
              major southwest research university served as the
              subjects for this study. Subjects were randomly
              assigned to either an abstract model group or a
              concrete model group and the groups were of
              approximately equal size. Different conceptual
              models (abstract or concrete) were used to present
              recursion to the two model groups. Within each model
              group, subjects were identified as either an
              abstract learner or a concrete learner based on
              their scores on the scrambled Kolb's Learning-Style
              Inventory 1985. A posttest and two retention tests
              were administered after the treatment to compare
              students' performance in different groups. A pretest
              administered prior to the treatment was used to
              equate the variance caused by students' prior
              knowledge in the statistical analysis. The
              statistical procedure of two-way ANCOVA was employed
              to analyze all of the performance data.  The
              findings of this study are: Concrete conceptual
              models were better than abstract conceptual models
              in teaching recursion to novice programmers. However, 
              the teaching effects weakened several weeks after 
              classroom instruction. Novice programmers with abstract 
              learning styles performed better than those with
              concrete learning styles when  learning recursion. 
              Finally, abstract learners did
              not necessarily benefit more from abstract
              conceptual models, and concrete learners did not
              necessarily benefit more from concrete conceptual
              models.  A replication study with a longer treatment
              period that covers more aspects of recursive
              programming is recommended for future
              research. Additional research needs to be conducted
              to better understand students' mental models of
              recursion. Furthermore, future research should
              investigate how the other dimension of Kolb's
              learning styles (i.e., active-reflective) relates to
              the instructional methods provided. It is also
              recommended that the relationship between the
              characteristic of learning tasks (or domains) and
              the matching of learning styles with conceptual
              models be investigated.}
}

@Misc{BhuiyanGreerGordon:1994,
  author       = {Shawkat Bhuiyan and Jim E. Greer and Gordon I. McCalla},
  title        = {Supporting the learning of recursive problem solving},
  howpublished = {University of Saskatchewan, Saskatchewan, Canada},
  year         = 1994,
  abstract     = {This research is about the problem solving
                  activities of novice programmers as they learn to
                  create recursive LISP programs. Their problem
                  solving not only includes the issue of mental
                  models, but also how to use these mental models in
                  conjunction with other problem solving
                  techniques. In fact, at various stages of their
                  learning, learners seem to use different packages of
                  problem solving methods. Each of these packages we
                  call a mental method. In this paper, we discuss the
                  PETAL learning environment which assists learners in
                  the use of three of these mental methods: the
                  syntactic method, the analytic method and the
                  analysis/synthesis method. PETAL externalizes each
                  mental method through its own customized interface,
                  called a programming environment tool (PET). Such
                  externalization helps learners internalize concepts,
                  and organize relevant knowledge and generally leads
                  to improved learning.}
}

@InProceedings{WuDaleBethel:1998,
  author       = {Cheng-Chih Wu and Nell B. Dale and Lowell J. Bethel},
  title        = {Conceptual models and cognitive learning styles in
                  teaching recursion},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {292--296},
  year         = 1998,
  month        = mar,
  address      = {Atlanta, Georgia, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 0-89791-994-7},
  abstract     = {An experimental research design was implemented in an
                  attempt to understand how different types of
                  conceptual models and cognitive learning styles
                  influence novice programmers when learning
                  recursion. The results indicate that in teaching
                  recursion to novice programmers: (*) concrete
                  conceptual models are better than abstract
                  conceptual models; (*) novices with abstract
                  learning styles perform better than those with
                  concrete learning styles; (*) abstract learners do
                  not necessarily benefit more from abstract
                  conceptual models; and (*) concrete learners do
                  not necessarily benefit more from concrete
                  conceptual models.}
}

@InProceedings{George:2000a,
  author    = {Carlisle E. George},
  title     = {Experiences with novices: {T}he importance of
               graphical representations in supporting mental
               models},
  booktitle = {Workshop of the Psychology of Programming Interest
               Group},
  pages     = {33--44},
  year      = 2000,
  address   = {Cozenza, Italy},
  month     = apr,
  abstract  = {Recursion is an important problem solving technique used
               in programming. It is also a highly unfamiliar
               mental activity and many computing novices have
               difficult understanding recursion and applying
               recursive techniques in problem solving. Research
               studies have concluded that novices and experts
               differ in their mental models of recursion. Novices
               seem to possess various inadequate models of
               recursion especially the iterative or loop
               model. This paper examines whether novices who are
               aided in acquiring an expert’s mental model of
               recursion (the copies model) can effectively use
               this model in evaluating recursive
               algorithms. Results of a study indicated that a
               large percentage of novices who had previously
               demonstrated an understanding of the copies model
               (using explicit diagrammatic traces) failed do so
               when not using diagrammatic traces. In fact, they
               appeared to demonstrate evidence for the incorrect
               iterative or loop model when trying to mentally
               evaluate recursive programs. The results provide
               evidence that mental models are unstable and that
               graphical representations are a very necessary aid
               to retrieval of novices’ mental models. This
               suggests that the teaching of recursion may be best
               facilitated by teaching students how to simulate the
               execution of a recursive algorithm using
               diagrammatic traces.}
}

@Article{Ben-Ari:2001,
  author   = {Mordechai Ben-Ari},
  title    = {Constructivism in computer science education},
  journal  = {Journal of Computers in Mathematics and Science
              Teaching},
  year     = 2001,
  volume   = 20,
  number   = 1,
  pages    = {45--73},
  month    = jan,
  note     = {{ISSN} 0731-9258},
  abstract = {Constructivism is a theory of learning which claims that
              students construct knowledge rather than merely
              receive and store knowledge transmitted by the
              teacher. Constructivism has been extremely
              influential in science and mathematics education,
              but not in computer science education (CSE). This
              paper surveys constructivism in the context of CSE,
              and shows how the theory can supply a theoretical
              basis for debating issues and evaluating proposals.}
}

@InProceedings{daRosa:2007,
  author    = {Sylvia da Rosa},
  title     = {The learning of recursive algorithms from a
               psychogenetic perspective},
  booktitle = {Workshop of the Psychology of Programming Interest
               Group},
  year      = 2007,
  address   = {Joensuu, Finland},
  month     = jul,
  abstract  = {The ideas presented in this paper concern computer
               science education research within Jean Piaget's
               theory genetic epistemology. Results from Piaget
               and collaborators investigations about the recursive
               reasoning on the series of natural numbers are
               extended to learn about entering students recursive
               reasoning on other inductively defined structures. In
               this paper the main aspects of that extension are
               described using a selected example.} 
}


@comment Recursion in the didactics of programming

@Article{BellGilbert:1974,
  author  = {Stoughton Bell and Edgar J. Gilbert},
  title   = {Learning recursion with syntax diagrams},
  journal = {ACM SIGCSE Bull.},
  year    = 1974,
  volume  = 6,
  number  = 3,
  pages   = {44--45},
  month   = sep,
  note    = {{ISSN} 0097-8418}
}

@Article{Daykin:1974,
  author  = {P. N. Daykin},
  title   = {Teaching recursive programming using {BASIC}},
  journal = {ACM SIGCUE Outlook},
  year    = 1974,
  volume  = 8,
  number  = 1,
  pages   = {11--13},
  month   = jan,
  note    = {{ISSN} 0163-5735},
  abstract = {The value of a recursive programming capability in a
              high level programming language is now generally
              recognized. The teaching of recursive programming,
              however, is often postponed to a second-semester
              college course in computing science, as if the topic
              belonged to an advanced level, though it has been
              shown that recursion can be grasped by students of 
              mathematics at the secondary school level or earlier. 
              One unfortunate result of this postponement of 
              recursion in computing science teaching is that 
              students who take one semester only carry away with 
              them the false notion that computers are limited 
              intrinsically to understanding iterative processes.}
}

@InProceedings{Kimura:1977,
  author       = {Takayuki Kimura},
  title        = {Recursive programming in {E}nglish for freshmen},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {129--132},
  year         = 1977,
  month        = feb,
  address      = {Atlanta, Georgia, USA},
  organization = {ACM \textsc{sigcse}},
  abstract     = {The importance of recursive programming in an 
                  introductory computer science course is discussed
                  from the viewpoint that the notions of `process',
                  `program' and `processor' are fundamental in 
                  computer programming. Several examples demonstrate
                  how the concept of recursive programming and proving
                  program correctness can be taught to freshman
                  business majors before they are exposed to any
                  programming language.}
}

@Article{BunemanLevy:1980,
  AUTHOR  = {Peter Buneman and Leon Levy},
  TITLE   = {The towers of {H}anoi problem},
  JOURNAL = {Information Processing Letters},
  VOLUME  = {10},
  NUMBER  = {4--5},
  PAGES   = {243--244},
  DAY     = {5},
  MONTH   = jul,
  YEAR    = 1980
}

@InProceedings{Kruse:1982,
  author       = {Robert L. Kruse},
  title        = {On teaching recursion},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {92--96},
  year         = 1982,
  month        = feb,
  address      = {Indianapolis, Indiana, USA},
  organization = {ACM SIGCSE},
  note         = {{ISBN} 0-89791-067-2},
  abstract     = {Tree diagrams can be fruitfully employed in
                  elementary courses to illustrate recursion,
                  explain its implementation, and motivate its
                  applications in algorithm design. At the same 
                  time, tree diagrams can lead to guidelines to 
                  help the student decide when recursion is a 
                  good method, and when it should be avoided. 
                  This paper discusses these methods and, as an
                  example, develops an algorithm for generating
                  permutations.}
}

@InProceedings{AnzaiUesato:1982,
  author    = {Yuichiro Anzai and Y. Uesato},
  title     = {Learning recursive procedures by middle\hyp{}school
               children},
  booktitle = {Conf. of the Cognitive Science Society},
  pages     = {100--102},
  year      = 1982
}

@Article{Ford:1982,
  author   = {Gary Ford},
  title    = {A framework for teaching recursion},
  journal  = {ACM SIGCSE Bull.},
  year     = 1982,
  volume   = 14,
  number   = 2,
  pages    = {32--39},
  month    = jun,
  note     = {{ISSN} 0097-8418},
  abstract = {Recursion is presented as a generalized control
              structure, with iteration being a special case. A
              method is described to determine when to use
              recursion and when to use iteration in designing an
              algorithm to solve a problem.}
}

@InProceedings{Kahney:1983,
  author       = {Hank Kahney},
  title        = {What do novice programmers know about recursion},
  booktitle    = {Conf. on Human Factors in Computing Systems},
  pages        = {235--239},
  year         = 1983,
  month        = dec,
  address      = {Boston, Massachusetts, USA},
  organization = {ACM \textsc{sigchi}},
  note         = {{ISBN} 0-89791-121-0},
  abstract     = {Recent research into differences between novice and
                  expert computer programmers has provided evidence
                  that experts know more than novices, and what they
                  know is better organized. The conclusion is only as
                  interesting as it is intuitive. This paper reports
                  an experiment which was designed to determine
                  precisely what novice programmers understand about
                  the behaviour of recursive procedures, and exactly
                  how their understanding differs from an expert's
                  understanding of the process. The results show that
                  different novices understand, or misunderstand,
                  different things. Implications of the findings are
                  discussed with respect to other research into novice
                  and expert programming performance.}
}

@InProceedings{AndersonPirolliFarrell:1984,
  author    = {John R. Anderson and Peter Pirolli and Robert
               Farrell},
  title     = {Learning to program recursion},
  booktitle = {Conf. of the Cognitive Science Society},
  pages     = {277--280},
  year      = 1984,
  address   = {Boulder, Colorado, USA},
  abstract  = {Learning to program recursive functions in languages
               like LISP is notoriously difficult. Indeed, a 
               primary mark of expertise in such languages is the
               ability to plan and code recursive functions. 
               Recently, we have performed protocol studies of
               students learning to program recursion in LISP and 
               Logo as well as controlled experiments on learning
               recursion in a simple programming language. We have
               used the GRAPES production system model to address
               these results. GRAPES not only models programming
               performance but also learning by doing by the 
               mechanism of \emph{knowledge compilation}. Knowledge 
               compilation summarizes extensive problem-solving 
               operations into new compact production rules.}
}

@Article{Ford:1984,
  author   = {Gary Ford},
  title    = {An implementation\hyp{}independent approach to teaching
              recursion},
  journal  = {ACM SIGCSE Bull.},
  year     = 1984,
  volume   = 16,
  number   = 1,
  pages    = {213--216},
  month    = feb,
  note     = {{ISSN} 0097-8418},
  abstract = {The principle of abstraction, of separating a concept
              from a particular implementation of that concept, is
              gaining increasingly widespread use in programming
              and problem solving, and in teaching these
              subjects. A method of teaching the abstract concept
              of recursion, independent of its implementation, is
              presented.}
}

@InProceedings{KurtzJohnson:1985,
  author       = {Barry L. Kurtz and Dennis Johnson},
  title        = {Using simulation to teach recursion and binary tree
                  traversals},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {49--54},
  year         = 1985,
  month        = mar,
  address      = {New Orleans, Louisiana, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 0-89791-152-0},
  abstract     = {Computer science students must often be able to
                  mentally execute "static" source code to envision
                  "dynamic" changes in data structures. This is a
                  difficult skill to acquire, however, the computer
                  itself can help students develop such talents
                  through well designed simulations. This paper
                  reports on one such simulation, recursive traversals
                  of binary trees, developed as part of an NSF grant. 
                  The processes of pedagogical design, screen design,
                  top down program coding, and field testing are
                  described in detail. Based on these field tests, it
                  is clear that simulations help students understand
                  difficult concepts, such as recursion and tree
                  traversals.}
}

@Article{Kilpatrick:1985,
  author  = {Jeremy Kilpatrick},
  title   = {Reflection and recursion},
  journal = {Educational Studies in Mathematics},
  year    = 1985,
  volume  = 16,
  number  = 1,
  pages   = {1--26},
  month   = feb
}

@Article{LeronZazkis:1986,
  author  = {Uri Leron and Rina Zazkis},
  title   = {Computational recursion and mathematical induction}, 
  journal = {For the Learning of Mathematics},
  year    = 1986,
  volume  = 6,
  number  = 2,
  pages   = {25--28},
  month   = jun
}

@Article{KesslerAnderson:1986,
  author   = {Claudius M. Kessler and John R. Anderson},
  title    = {Learning flow of control: recursive and iterative
              procedures},
  journal  = {Human\hyp{}Computer Interaction},
  year     = 1986,
  month    = jun,
  volume   = 2,
  number   = 2,
  pages    = {135--166},
  note     = {{ISSN} 0737-0024},
  abstract = {Two experiments were performed to study students'
              ability to write recursive and iterative programs
              and transfer between these two skills. Subjects
              wrote functions to accumulate instances into a
              list. Problems varied in terms of whether they were
              recursive or iterative, whether they operated on
              lists or numbers, whether they accumulated results
              in forward or backward manner, whether they
              accumulated on success or failure, and whether they
              simply skipped or ejected on failure to
              accumulate. Subjects had real difficulty only with
              the dimensions concerned with flow of control,
              namely, recursive versus iterative, and skip versus
              eject. We found positive transfer from writing
              iterative functions to writing recursive functions,
              but not vice versa. A subsequent protocol study
              revealed subjects had such a poor mental model of
              recursion that they developed poor learning
              strategies which hindered their understanding of
              iteration. It is argued that having an adequate
              model of the functionality of programming is
              prerequisite to learning to program, and that it is
              sensible pedagogical practice to base understanding
              of recursive flow of control on understanding
              iterative flow of control.}
}

@InProceedings{Wiedenbeck:1988,
  author       = {Susan Wiedenbeck},
  title        = {Learning recursion as a concept and as a programming
                  technique},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {275--278},
  year         = 1988,
  month        = feb,
  address      = {Atlanta, Georgia, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 0-89791-256-X},
  abstract     = {Two experiments on learning recursion and iteration
                  were carried out. The first studied learning of the
                  mathematical concept of recursion by having subjects
                  compute mathematical functions by analogy to worked
                  out examples. The results suggest that subjects are
                  quite able to induce a computational procedure for
                  both iterative and recursive functions from
                  examples. Furthermore, prior practice with iterative
                  examples does not seem to facilitate subsequent
                  performance on similar recursive problems, nor does
                  prior practice with recursive examples facilitate
                  performance on iterative problems. The second
                  experiment studied novice subjects' comprehension of
                  iterative and recursive Pascal programs. 
                  Comprehension of the iterative program was not 
                  improved by prior exposure to the recursive version 
                  of the program. Comprehension of the recursive 
                  version was improved moderately by prior work with 
                  the iterative version.}
}

@InProceedings{ElenbogenOKennon:1988,
  author       = {Bruce S. Elenbogen and Martha R. O'Kennon},
  title        = {Teaching recursion using fractals in {P}rolog},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {263--266},
  year         = 1988,
  month        = feb,
  address      = {Atlanta, Georgia, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 0-89791-256-X},
  abstract     = {Recursion has traditionally been a difficult concept
                  for students to understand, both as a control
                  structure and as an analytical tool. This paper
                  explores recursion using Prolog (whose predominate
                  control structure is recursion) and through fractals
                  which possess a visually recursive form. We discuss
                  several simple Turbo Prolog programs which
                  demonstrate recursion graphically and whose
                  resultant figures are fractals whose recursive
                  nature is particularly easy to analyze in the Turbo
                  Prolog environment.}
}

@InBook{Glaser:1988,
  author    = {John R. Anderson and Peter Pirolli and Robert
               Farrell},
  title     = {The nature of expertise},
  chapter   = {Learning to program recursive functions},
  publisher = {Lawrence Erlbaum},
  year      = 1988,
  address   = {Hillsdale, New Jersey, USA},
  pages     = {153--183}
}

@Article{LissMcMillan:1988,
  author   = {Ivan B. Liss and Thomas C. McMillan },
  title    = {An amazing exercise in recursion for {CS1} and {CS2}},
  journal  = {ACM SIGCSE Bull.},
  year     = 1988,
  volume   = 20,
  number   = 1,
  pages    = {270--274},
  month    = feb,
  note     = {{ISSN} 0097-8418},
  abstract = {This paper describes an exercise which has been used in
              both CS1 and CS2 courses for the purpose of introducing
              the concepts of recursion and stacks, and for
              illustrating the benefits of procedural abstraction. The
              problem is to write a program which finds a path through
              a rectangular maze. The exercise is used in CS1 as part
              of an introduction to recursion. In CS2, it is used to
              illustrate and employ the abstract data type "stack." In
              both exercises, the ideas are presented so as to
              reinforce the concepts of top-down design, and
              procedural and data abstraction.}
}

@InProceedings{Leron:1988,
  author    = {Uri Leron},
  title     = {What makes recursion hard?},
  booktitle = {International Congress of Mathematics Education},
  year      = 1988
}

@InProceedings{HendersonRomero:1989,
  author       = {Peter B. Henderson and Francisco J. Romero},
  title        = {Teaching recursion as a problem\hyp{}solving tool
                  using {S}tandard {ML}},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {27--31},
  year         = 1989,
  month        = feb,
  address      = {Louisville, Kentucky, USA},
  organization = {ACM \textsc{sigcse}/IEEE-CS},
  note         = {{ISBN} 0-89791-289-5},
  abstract     = {Standard ML is a state of the art functionala
                  programming language, with features that make it
                  excellent for teaching recursion and problem solving
                  at the introductory level. Among the many
                  pedagogically interesting characteristics of ML are
                  its simple and uniform syntax, its type polymorphism
                  and type inferencing system, and datatype
                  declaration facilities. With little formal ML
                  instruction, after several weeks first year students
                  were able to use recursively defined data structures
                  and to define fairly powerful recursive functions in
                  ML. Standard ML is highly recommended as a tool for
                  teaching recursive problem solving in the context of
                  a course on the foundations of computer science.}
}

@Article{Wiedenbeck:1989,
  author   = {Susan Wiedenbeck},
  title    = {Learning iteration and recursion from examples},
  journal  = {International Journal of Man\hyp{}Machine Studies}, 
  year     = 1989,
  volume   = 30,
  number   = 1,
  pages    = {1--22},
  month    = jan,
  note     = {{ISSN} 0020-7373},
  abstract = {Description de trois expériences d'apprentissage des
              notions d'itération et de récursivité. Dans la
              première, il est étudié comment les sujets
              apprennent à programmer des fonctions mathématiques,
              telle la factorielle, à partir d'exemples. Dans la
              deuxième, est analysée l'utilisation des
              connaissances acquises à partir d'exemples
              récursifs dans la programmation d'une fonction
              mathématique récursive similaire, présentée d'une
              forme abstraite. La troisième expérience aborde la
              compréhension de programmes itératifs et récursifs
              écrits en Pascal}
}

@Article{Shavlik:1990,
  author   = {Jude W. Shavlik},
  title    = {Acquiring recursive and iterative concepts with
              explanation\hyp{}based learning},
  journal  = {Machine Learning},
  year     = 1990,
  volume   = 5,
  number   = 1,
  pages    = {39--70},
  month    = mar,
  note     = {{ISSN} 0885-6125},
  abstract = {In explanation-based learning, a specific problem's
              solution is generalized into a form that can be
              later used to solve conceptually similar
              problems. Most research in explanation-based
              learning involves relaxing constraints on the
              variables in the explanation of a specific example,
              rather than generalizing the graphical structure of
              the explanation itself. However, this precludes the
              acquisition of concepts where an iterative or
              recursive process is implicitly represented in the
              explanation by a fixed number of applications. This
              paper presents an algorithm that generalizes
              explanation structures and reports empirical results
              that demonstrate the value of acquiring recursive
              and iterative concepts. The BAGGER2 algorithm learns
              recursive and iterative concepts, integrates results
              from multiple examples, and extracts useful
              subconcepts during generalization. On problems where
              learning a recursive rule is not appropriate, the
              system produces the same result as standard
              explanation-based methods. Applying the learned
              recursive rules only requires a minor extension to a
              PROLOG-like problem solver, namely, the ability to
              explicitly call a specific rule. Empirical studies
              demonstrate that generalizing the structure of
              explanations helps avoid the recently reported
              negative effects of learning.}
}

@Article{BundyGrosseBrna:1991,
  author   = {Alan Bundy and Gerd Grosse and Paul Brna},
  title    = {A recursive techniques editor for {P}rolog},
  journal  = {Instructional Science},
  year     = 1991,
  volume   = 20,
  number   = {2-3},
  pages    = {135--172},
  month    = mar,
  note     = {{ISSN} 0020-4277},
  abstract = {We describe an editor geared to recursive Prolog
              procedures. It is similar to the structure editors built
              for many programming languages, except that instead of
              just ensuring the correctness of the syntax of the
              procedures builts by the editor, the editor also ensures
              the correct use of recursion. By correct we mean that
              the recursive procedure is guaranteed to terminate and
              to be well\hyp{}defined. Within these constraints we
              have tried to ensure that the range of procedures that 
              can be built is as complete as possible.}
}

@InProceedings{Dorf:1992,
  author       = {Mary Lou Dorf},
  title        = {Backtracking the rat way},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {272--275},
  year         = 1992,
  month        = mar,
  address      = {Kansas City, Missouri, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 0-89791-468-6},
  abstract     = {Have you ever mentioned recursion with backtracking
                  and had the students cringe? To some students who
                  have previously encountered recursion, the very
                  mention of the word is enough to strike terror in
                  their hearts. Once backtracking is added to the
                  concept of recursion, they are ready to flee the
                  room and the course. The following method of
                  presenting backtracking via recursion may change
                  student terror to titillation.}
}

@Article{Haynes:1995,
  author   = {Susan Makrouhee Haynes},
  title    = {Explaining recursion to the unsophisticated},
  journal  = {ACM SIGCSE Bull.},
  year     = 1995,
  volume   = 27,
  number   = 3,
  pages    = {3--6},
  month    = sep,
  note     = {{ISSN} 0097-8418},
  abstract = {This paper addresses the topic of explaining recursion
              to beginning programmers. It briefly presents the common
              approaches, then describes an extension to those methods
              called \emph{activation tree}.}
}

@PhdThesis{George:1996,
  author = {Carlisle Eldwidge George},
  title  = {Investigating the effectiveness of a
            software\hyp{}reinforced approach to understanding
            recursion},
  school = {Univ. of London},
  year   = 1996,
  note   = {275 pages}
}

@Article{Ben-AriReich:1996,
  author   = {Mordechai Ben-Ari},
  title    = {Recursion: {F}rom drama to program},
  journal  = {Aspects of Teaching Computer Science},
  year     = 1996,
  volume   = 7,
  pages    = {45--47},
  abstract = {This paper describes a novel approach to teaching
              recursion: couple a real-world problem that can be
              dramatized to a programming problem whose solution
              exactly parallels the dramatization. Three such
              pairs of problems are presented in order of
              difficulty: a procedure, a function and a procedure
              with two recursive invocations. We also show how
              the program for the Towers of Hanoi can be made to
              parallel the algorithm for playing the game.}
}

@InProceedings{Proulx:1997,
  author       = {Viera K. Proulx},
  title        = {Recursion and grammars for CS2},
  booktitle    = {Conf. on Integrating Technology into
                  Comp. Sci. Education},
  pages        = {74--76},
  year         = 1997,
  month        = jun,
  address      = {Uppsala, Sweden},
  organization = {ACM \textsc{sigcse-sigcue}},
  note         = {{ISBN} 0-89791-923-8},
  abstract     = {A programming exercise on recursion in which
                  students create drawings of simple and bracketed
                  Lindenmayer Systems provides a context for exploring
                  additional computer science concepts. The resulting
                  drawings give students a better understanding of the
                  power of recursion as well as the rate of growth of
                  time complexity with multiple successive recursive
                  calls. We describe the exercise, the concepts that
                  need to be addressed to solve the problems, and the
                  results of using this exercise in our classes.}
}

@InProceedings{CloseDicheva:1997,
  author    = {John Close and Darina Dicheva},
  title     = {Misconceptions in recursion: {D}iagnostic teaching},
  booktitle = {European Logo Conf.},
  year      = 1997,
  address   = {Budapest, Hungary},
  month     = aug,
  abstract  = {The paper describes a diagnostic teaching approach to
               recursion in Logo. The approach involves a general
               strategy for teaching recursion and specific
               teaching tactics for alleviating the misconceptions
               which underly flawed mental models of the recursive
               process possessed by particular learners. The
               erroneous mental models and underlying
               misconceptions had been identified and described in
               an earlier study by the two authors. Further
               research to test the approach is recommended.}
}

@Article{Chen:1998,
  author   = {Ming-Puu Chen},
  title    = {The effect of dynamic copies model in teaching
              recursive programming},
  journal  = {Journal of Taiwan Normal University},
  year     = 1998,
  volume   = 43,
  number   = 1,
  pages    = {63--78},
  abstract = {The copies model of recursion was implemented in two
              versions of computer-based instruction (dynamic
              vs. static) in this study. For the immediate effects, 
              dynamic copies model was more effective than static
              copies model in teaching recursion. High prior knowledge
              students performed better than low prior knowledge
              students no matter they were instructed with the dynamic
              or static model. For the delayed effects, ATI was found.
              High prior knowledge students benefited from the static
              copies model isntructin more than from the dynamic copies
              model. In contrast, low prior knowledge students benefited
              from the dynamic copies model more than from the static
              copies model.}          
}

@InProceedings{Velazquez:1999,
  author    = {J. \'Angel Vel\'azquez-Iturbide},
  title     = {A progressive approach to recursion},
  booktitle = {Frontiers in Education Conf.},
  pages     = {34--38},
  year      = 1999,
  volume    = 1,
  address   = {San Juan, Puerto Rico},
  month     = nov,
  publisher = {IEEE},
  note      = {{ISBN} 0-7803-5643-8},
  abstract  = {We propose a progressive approach to simplify teaching
               recursion. It is introduced by means of three
               instances of increasing level of difficulty. First,
               recursion is introduced in a“pure”form as it is
               found in formal grammars; its accompanying
               mechanisms are related to rewriting. Later, a
               functional programming language allows defining
               recursive functions and recursive data types; its
               mechanisms are associated to algorithmics and
               rewriting. Finally, recursion is shown in imperative
               languages, together with mechanisms about
               algorithmics and state transformations.  The
               approach has three main advantages. First, the
               student perceives recursion as a recurrent concept
               in the discipline of computer science, not only
               existing in imperative programming. Second, the
               concept of recursion is isolated and differentiated
               from other concepts or mechanisms which are
               associated to particular instances of recursion. 
               Finally, the teaching of recursion is simplified 
               because it is taught in a progressive way.}
}

@Article{TurbakRoydenStephanHerbst:1999,
  author   = {Franklyn Turbak and Constance Royden and Jennifer
              Stephan and Jean Herbst},
  title    = {Teaching recursion before loops in {CS1}},
  journal  = {Journal of Computing in Small Colleges},
  year     = 1999,
  volume   = 14,
  number   = 4,
  pages    = {86--101},
  month    = may,
  abstract = {Traditionally, loops are a central topic in a CS1 course
              but recursion is viewed as an advanced topic that is
              either taught near the end of the course or not taught
              at all. Taking a cue from the function-oriented 
              programming community, we argue that there are strong 
              pedagogical reasons for teaching recursion before loops 
              in a CS1 course, regardless of what programming paradigm 
              is taught. In our approach, recursion is presented as an 
              instance of the classic "divide, conquer, and glue" 
              problem solving strategy. Iteration is then presented as 
              a particular pattern of recursion. Finally, loop 
              constructs are presented as concise idioms for iterative 
              patterns. We describe our positive experience in
              adopting this approach in a CS1 course and highlight the 
              aspects of the course that we think contribute to its 
              success.}
}

@InProceedings{GinatShifroni:1999,
  author       = {David Ginat and Eyal Shifroni},
  title        = {Teaching recursion in a procedural environment--how
                  much should we emphasize the computing model?},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {127--131},
  year         = 1999,
  month        = mar,
  address      = {New Orleans, Louisiana, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-085-6},
  abstract     = {Recursion is a powerful and essential computational
                  problem solving tool, but the concept of recursion
                  is difficult to comprehend. Students that master the
                  conventional programming construct of iteration in
                  procedural programming environments, find it hard to
                  utilize recursion. This study started as a test of
                  CS College students' utilization of recursion. It
                  was conducted after they have completed CS1, where
                  they studied recursion with the C programming
                  language. The test revealed that students adhere to
                  the iterative pattern of "forward accumulation", due
                  to their confidence with the iteration construct,
                  but lack of trust of the recursion mechanism. These
                  results motivated us to get more insight into the
                  nature of recursion difficulties and ways to
                  overcome them.In this paper we describe the
                  difficulties we observed, and present a declarative,
                  abstract, approach that contributed to overcome
                  them. We question the emphasis that should be put on
                  the basic computing model when presenting recursion,
                  and argue for emphasis on the declarative approach
                  for teaching recursion formulation in a procedural
                  programming environment.},
  comment      = {Recursion is hard to learn after learning
                  iteration. Study on college CS students: they
                  already learnt C and recursion. Recursion is traced
                  or animated, but this is too low-level (not
                  declarative enough): the authors want to question
                  that trend. Recursion is harder to trace than
                  iteration. Iteration leads to incorrect mental
                  models when learning recursion (only "copies model"
                  is considered correct by Kahney): the latter is
                  thought as an expression of the familiar counting
                  and accumulation technique within loops; the
                  recursive call is not the consequence of the
                  analysis of the original problem but is thought
                  bottom-up, from the previous, low-level computing
                  model. The base case is viewed as a stopping
                  condition as if in a loop (thus non-tail-form
                  recursive calls are wrong). Teachers of C tend to
                  emphasize iterations.}
}

@InProceedings{Velazquez:2000,
  author       = {J. \'Angel Vel\'azquez-Iturbide},
  title        = {Recursion in gradual steps (is recursion really that
                  difficult?)},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {310--314},
  year         = 2000,
  month        = mar,
  address      = {Austin, Texas, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-213-1},
  abstract     = {We propose a gradual approach to teach
                  recursion. Our main assumption is that the
                  difficulty in learning recursion does not come from
                  the recursion concept itself, but from its
                  interaction with other mechanisms of imperative
                  programming. We use this basic idea to propose a new
                  pedagogical approach. On the one hand, recursion is
                  introduced in a gradual way by means of three fields
                  (grammars, functional programming and imperative
                  programming). On the other hand, each instance of
                  recursion is explained so that all of its
                  accompanying mechanisms are clearly identified. The
                  approach has three main advantages. First, the
                  teaching of recursion is simplified because it is
                  taught in a gradual way. Second, the concept of
                  recursion is isolated and differentiated from other
                  concepts or mechanisms associated to particular
                  instances of recursion. Last, the student perceives
                  recursion as a recurrent concept in the discipline
                  of computer science.}
}

@InProceedings{LevyLapidot:2000,
  author       = {Dalit Levy and Tami Lapidot},
  title        = {Recursively speaking: analyzing students' discourse
                  of recursive phenomena},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {315--319},
  year         = 2000,
  month        = mar,
  address      = {Austin, Texas, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-213-1},
  abstract     = {Recursion is a powerful concept, appearing in
                  almost every introductory course in computer-science
                  (CS). CS educators and educational researchers often
                  refer to difficulties in learning recursion, and
                  suggest methods for teaching recursion. However, the
                  research literature barely addresses the unique ways
                  in which students relate to this interdisciplinary
                  concept and the particular learners' language
                  concerning recursive phenomena. The gap is most
                  apparent when seen through a constructivist lens,
                  where the students' prior knowledge and
                  idiosyncratic conceptions should be referred to and
                  reflected upon in order to serve as a basis for
                  further knowledge construction. This paper reports
                  on a study in which a collaborative classification
                  of several recursive phenomena is used to facilitate
                  the construction of recursion. The students'
                  discourse was analyzed, as a step toward
                  understanding the students' ways of speaking
                  recursively. Preliminary results indicate some basic
                  aspects of recursion in the student discourse,
                  although the students apparently talk a very
                  different language from that of the experts, as used
                  by books and teachers.}
}

@Article{Levy:2001,
  author   = {Dalit Levy},
  title    = {Insights and conflicts in discussing recursion: {A}
              case study},
  journal  = {Computer Science Education},
  year     = 2001,
  volume   = 11,
  number   = 4,
  pages    = {305--322},
  month    = dec,
  abstract = {Recursion is a signi®cant concept, appearing in almost
              every introductory course in Computer Science (CS). CS
              educators and educational researchers often refer to 
              difficulties in learning and teaching recursion. 
              However, the research literature barely addresses the 
              unique ways in which students relate to this 
              interdisciplinary concept and the particular learners' 
              language concerning recursive phenomena. The gap is most
              apparent when seen through a constructivist lens, where 
              the students' prior knowledge and idiosyncratic 
              conceptions should be referred to and reflected upon in 
              order to serve as a basis for further knowledge 
              construction. This paper reports on a study in which a 
              collaborative classification of several recursive 
              phenomena are used to facilitate the construction of
              recursion. The student discourse was recorded and
              analyzed, and a grounded categorical system was formed 
              and examined. Preliminary results indicate some basic 
              aspects of recursion in the student discourse, although 
              the students apparently talk a very different language 
              from that of the experts. Some `potentially rich' 
              discourse episodes were evident as well, representing 
              conflicts among alternative conceptions. Such episodes 
              can serve as a springboard for further learning.}
}

@InProceedings{Sooriamurthi:2001,
  author       = {Raja Sooriamurthi},
  title        = {Problems in comprehending recursion and suggested
                  solutions},
  booktitle    = {Conf. on Innovation and Technology into Computer
                  Science Education},
  pages        = {25--28},
  year         = 2001,
  address      = {Canterbury, UK},
  month        = jun,
  organization = {ACM \textsc{sigcse-sigcue}},
  note         = {{ISBN} 1-58113-330-8},
  abstract     = {Recursion is a very powerful and useful problem
                  solving strategy. But, along with pointers and
                  dynamic data structures, many beginning programmers
                  consider recursion to be a difficult concept to
                  master. This paper reports on a study of
                  upper-division undergraduate students on their
                  difficulty in comprehending the ideas behind
                  recursion. Three issues emerged as the points of
                  difficulty for the students: (1) insufficient
                  exposure to declarative thinking in a programming
                  context (2) inadequate appreciation of the concept
                  of functional abstraction (3) lack of a proper
                  methodology to express a recursive solution. The
                  paper concludes with a discussion of our approach to
                  teaching recursion, which addresses these
                  issues. Classroom experience indicates this approach
                  effectively aids students' comprehension of
                  recursion.}
}

@InProceedings{HabermanAverbuch:2002,
  author       = {Bruria Haberman and Haim Averbuch},
  title        = {The case of base cases: why are they so difficult to
                  recognize? {S}tudent difficulties with recursion},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {84--88},
  year         = 2002,
  month        = jun,
  address      = {Aarhus, Denmark},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-499-1},
  abstract     = {Recursion is a central concept in computer science,
                  yet it is a very difficult concept for beginners to
                  learn. In this paper we focus on a specific aspect
                  of comprehending recursion - the conception of the
                  base case as an integral component of a recursive
                  algorithm. We found that students have difficulties
                  in identifying base cases: they handle redundant
                  base cases; ignore boundary values and degenerated
                  cases; avoid out-of-range values; and may even not
                  define any base cases when formulating recursive
                  algorithms. We also found that students have
                  difficulties in evaluating recursive algorithms that
                  deal with imperceptible base cases. We suggest that
                  teachers should make a special effort to discuss
                  different aspects of the base case concept. Emphasis
                  should be put on both declarative and procedural
                  aspects of categorizing and handling base cases as
                  part of recursion formulation.}
}

@InProceedings{LevyLapidot:2002,
  author       = {Dalit Levy and Tami Lapidot},
  title        = {Shared terminology, private syntax: the case of
                  recursive descriptions},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {89--93},
  year         = 2002,
  address      = {Aarhus, Denmark},
  month        = jun,
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-499-1},
  abstract     = {This paper reports a study in which 11th grade
                  students were observed, while engaged in several
                  learning activities that address general aspects of
                  recursion. One of these learning activities focused
                  on the creation of recursive descriptions using
                  natural language. The class discourse was recorded
                  and analyzed, in order to locate patterns of
                  students' expressions and ways of thinking. The
                  present finding is two-fold. On the one hand, a
                  class genre was created and used to refer to
                  recursive phenomena and to describe them
                  verbally. On the other hand, although they used a
                  shared set of some agreed-upon terms, the students
                  tended to individually construct their unique
                  recursive descriptions. These individual methods of
                  assembly are labeled hereafter as "private
                  syntax". It is concluded that learners' and
                  educators' awareness of both the "building blocks"
                  of any recursive description and the several
                  possibilities for assembling these blocks, might
                  help in the process of understanding recursion in
                  general and in further construction of recursive
                  functions in particular.}
}

@Article{Bloch:2003,
  author   = {Stephen Bloch},
  title    = {Teaching linked lists and recursion without
              conditionals or null},
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2003,
  volume   = 18,
  number   = 5,
  pages    = {96--108},
  month    = may,
  note     = {{ISSN} 1937-4771},
  abstract = {We describe a natural and principled approach to
              teaching linked data structures and recursion in
              CS0, CS1 or CS2, and compare the difficulty of using
              this approach in C++, Java, and Scheme.}
}

@Article{Haberman:2004,
  author  = {Bruria Haberman},
  title   = {How learning logic programming affects recursion
             comprehension},
  journal = {Computer Science Education},
  year    = 2004,
  volume  = 14,
  number  = 1,
  pages   = {37--53}
}

@Article{BrandtRichey:2004,
  author   = {Keith Brandt and Margaret Richey},
  title    = {Studying mathematical induction and recursive programming
              together}, 
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2004,
  volume   = 19,
  number   = 4,
  pages    = {108--114},
  month    = apr,
  note     = {{ISSN} 1937-4771},
  abstract = {Mathematical induction is a proof technique used
              throughout mathematics, and recursion is a
              programming concept frequently used in computer
              science. This note will explore the parallel between
              induction proofs and recursive programs by providing
              several example problems that lead to an induction
              proof and a corresponding recursive program. We feel
              that students who are exposed to this parallel will
              gain a deeper understanding of both topics.}
}

@InProceedings{Ginat:2004,
  author       = {David Ginat},
  title        = {Do senior {CS} students capitalize on recursion?},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {82--86},
  year         = 2004,
  month        = jun,
  organization = {ACM \textsc{sigcse-sigcue}},
  address      = {Leeds, UK},
  note         = {{ISBN} 1-58113-836-9},
  abstract     = {CS students learn and practice recursion in CS1,
                  data structures, introduction to algorithms, and
                  additional courses throughout the curriculum. 
                  Previous studies revealed difficulties of CS1 
                  students with the concept and the construct of 
                  recursion. What about advanced students? They may
                  well understand the concept and the construct of
                  recursion; but do they invoke and utilize recursion
                  as a problem solving means? The paper examines this
                  aspect, with senior CS students. The students were
                  given three algorithmic tasks, for which the
                  suitable solution approach was recursive. The
                  student solutions and explanations demonstrate very
                  limited capitalization on recursion as a problem
                  solving means. We discuss the findings and suggest
                  pedagogical implications for teaching.}
}

@Article{Ginat:2005,
  author   = {David Ginat},
  title    = {The suitable way is backwards, but they work
              forward},
  journal  = {Journal of Computers in Mathematics and
              Science Teaching},
  year     = 2005,
  volume   = 24,
  number   = 1,
  pages    = {73--88},
  month    = jan,
  note     = {{ISSN} 0731-9258},
  abstract = {Sometimes, if you do not begin at the end, you end at
              the beginning. This problem-solving phenomenon, in
              the realm of computer science (CS), is the subject
              of this paper. Beginning at the end yields a
              "working backwards" approach, opposite to that of
              "working forwards." One might expect 3rd year CS
              students to be aware of and effectively utilize both
              approaches. In particular, one might expect that
              students would work recursively backwards when it is
              the suitable way for solving a given algorithmic
              problem. The study in this paper reveals that this
              is not quite the case. The study shows that a large
              number of students work solely forwards and obtain
              erroneous or inefficient results, without
              considering any redirection of their train of
              thought. These students' working patterns are
              characterized and discussed. Suggestions for
              enabling their awareness and changing the direction
              of their reasoning are shown and advocated.}
}

@InProceedings{BruceDanylukMurtagh:2005,
  author       = {Kim B. Bruce and Andrea Danyluk and Thomas Murtagh},
  title        = {Why structural recursion should be taught before
                  arrays in {CS}~1},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {246--250},
  year         = 2005,
  month        = feb,
  address      = {St. Louis, Missouri, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN}:1-58113-997-7},
  abstract     = {The approach to teaching recursion in introductory
                  programming courses has changed little during the
                  transition from procedural to object-oriented
                  languages. It is still common to present recursion
                  late in the course and to focus on traditional,
                  procedural examples such as calculating factorials
                  or solving the Towers of Hanoi puzzle. In this
                  paper, we propose that the shift to object-oriented
                  programming techniques calls for a significant shift
                  in our approach to teaching recursion. First, we
                  argue that in the context of object-oriented
                  programming students should be introduced to
                  examples of simple recursive structures such as
                  linked lists and methods that process them, before
                  being introduced to traditional procedural
                  examples. Second, we believe that this material
                  should be presented before students are introduced
                  to structures such as arrays. In our experience, the
                  early presentation of recursive structures provides
                  the opportunity to reinforce the fundamentals of
                  defining and using classes and better prepares
                  students to appreciate the reasons to use classes to
                  encapsulate access to other data structures when
                  they are presented.}
}

@Misc{Ammari:2005,
  author       = {Mojtaba Ammari-Allahyari},
  title        = {Exploring students’understanding of the
                  relationship between iteration and recursion},
  howpublished = {Institute of Education, Univ. of Warwick},
  year         = 2005,
  abstract     = {In this study, I examine students’appreciation of
                  the relationship between recursion and iteration,
                  including how they perceive the intra-relationship
                  of the components within those processes. My
                  approach is to design a Logo-based microworld, which
                  acts as a window on the students’thinking. In this
                  environment, the students model trees and
                  fractal-shaped objects. I use a design-based
                  research methodology in order to gain insights into
                  students’understanding and design issues of the
                  software. These early results show that having a
                  clear understanding of the relation between
                  recursion and iteration and of the flow of control
                  are important in understanding the recursion
                  itself. In addition, functional abstraction is a key
                  concept in dealing with recursion. In the light of
                  these results, I am planning to open up the software
                  such that students will be able to engage with
                  recursion at two levels, namely “functionality”
                  and “functionnings”.}
}

@InProceedings{Polycarpou:2006,
  author    = {Irene Polycarpou},
  title     = {Computer {S}cience students' difficulties with
               proofs by induction: {A}n exploratory study},
  booktitle = {Southeast Regional Conf.},
  pages     = {601--606},
  year      = 2006,
  month     = mar,
  address   = {Melbourne, Florida, USA},
  publisher = {ACM},
  note      = {{ISBN} 1-59593-315-8},
  abstract  = {Induction is an important concept for computer science
               and yet students have difficulties understanding it. 
               The current literature on students’difficulties with
               induction is concerned with difficulties students have
               while proving a statement by induction. My research 
               focuses on identifying difficulties that students may 
               have prior to proving a statement. In particular, the 
               present paper is concerned with students’understanding
               of the recursive/inductive definition of the elements the
               statement is about. My study is contextualized within
               the undergraduate computer science curriculum, and its
               results show that students’performance with proofs by
               induction improves after class instruction, but not as
               it would be desirable. Moreover, they suggest that
               students who understand recursive/inductive definitions
               can successfully perform a proof by induction, while
               students who do not are either not able to perform
               proofs by induction, or if they are, they do so
               mechanically. In addition, students’performance is
               affected by their past knowledge and experience, as
               well as the context in which a problem is presented.}
}

@InProceedings{GinatArmoni:2006,
  author    = {David Ginat and Michal Armoni},
  title     = {Reversing: an essential heuristic in program and
               proof design},
  booktitle = {Tech. Symp. on Comp. Sci. Education},
  pages     = {469--473},
  year      = 2006,
  month     = mar,
  address   = {Houston, Texas, USA},
  publisher = {ACM},
  note      = {{ISBN} 1-59593-259-3},
  abstract  = {Program and proof designs are fundamental in computer
               science (CS). The designs involve the employment of
               various heuristics that may be considered rather
               inherent and natural, such as decomposition. Yet,
               not all heuristics are natural. One less natural,
               and rather unintuitive heuristic is that of
               reversing, in which a task is approached by
               reasoning backwards or viewing entities through
               "inverse lenses." One primary form of this
               heuristic is recursion. But, there are additional
               forms throughout the CS curriculum that are
               essential yet not underlined. In this paper we
               display these forms, underline their important role,
               and illustrate them in five core courses. In
               addition, we describe our experience with student
               difficulties due to unawareness and lack of
               competence with this heuristic, and offer
               preliminary guidelines for elaborating it during CS
               studies.}
}

@Article{Gordon:2006,
  author   = {Aaron Gordon},
  title    = {Teaching recursion using recursively\hyp{}generated
              geometric designs},
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2006,
  volume   = 22,
  number   = 1,
  pages    = {124--130},
  month    = oct,
  note     = {{ISSN} 1937-4771},
  abstract = {Teaching about recursion usually involves programs
              arriving at answers and displaying the results (for
              example: quicksort, summing elements in a linked
              list, evaluation of an expression tree). This paper
              discusses problems that naturally display results at
              each recursive step. Examples of these programs
              include those that visually display fractals and
              other geometric shapes recursively.}
}

@InProceedings{GoldwasserLetscher:2007,
  author       = {Michael Goldwasser and David Letscher},
  title        = {Teaching strategies for reinforcing structural
                  recursion with lists},
  booktitle    = {Conf. on Object Oriented Programming, Systems,
                  Languages and Applications},
  pages        = {889--896},
  year         = 2007,
  month        = oct,
  address      = {Montr\'eal, Qu\'ebec, Canada},
  organization = {ACM \textsc{sigplan}},
  note         = {{ISBN} 978-1-59593-865-7},
  abstract     = {Recursion is an important concept in computer
                  science and one that possesses beauty and
                  simplicity, yet many educators describe challenges
                  in teaching the topic. Kim Bruce champions the early
                  use of structural recursion in an object-oriented
                  introductory programming course as a more intuitive
                  concept than traditional (functional) recursion. He
                  uses many graphical examples for motivation (e.g.,
                  nested boxes, a ringed bullseye, fractals),
                  providing concreteness to the recursive
                  concept. Internally, most of those examples are
                  disguised forms of a basic recursive list
                  pattern. Recursive lists are important in and of
                  themselves and a mainstay within the functional
                  programming paradigm. However, further challenges
                  exist in providing a tangible presentation for pure
                  lists when disassociated from a graphical
                  structure.}
}

@Article{Edgington:2007,
  author   = {Jeffrey Edgington},
  title    = {Teaching and viewing recursion as delegation},
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2007,
  volume   = 23,
  number   = 1,
  pages    = {241--246},
  month    = oct,
  note     = {{ISSN}1937-4771},
  abstract = {We present an effective way to teach recursion which we
              believe nearly anyone can understand. Most people are 
              familiar with the concept of someone delegating a task
              to another person. Our method is based on this idea and 
              presents recursion as a particular form of task
              delegation. This simple form of delegation is similar to 
              the Little People metaphor. We then extend this form to 
              a more general description of task delegation. We
              believe that this extension improves understanding of
              how to program recursive procedures (especially by 
              end-users and novice programmers). Finally we discuss 
              the initial design of a recursion visualization based on 
              task delegation for the Greenfoot programming
              environment.}
}

@InProceedings{RubioHernan:2007,
  author       = {Manuel Rubio-S\'anchez and Isidoro Hern\'an-Losada},
  title        = {Exploring recursion with {F}ibonacci numbers},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {359--359},
  year         = 2007,
  address      = {Dundee, Scotland, UK},
  month        = sep,
  organization = {ACM \textsc{sigcse-sigcue}},
  note         = {{ISSN} 0097-8418},
  abstract     = {This paper addresses the relationship between
                  recursion and combinatorial problems, which may
                  benefit teaching recursion in CS1/2 courses. 
                  Problems whose solutions are related to Fibonacci
                  numbers are particularly interesting, since some
                  can be decomposed by using different strategies, 
                  which may be based on the numerous Fibonacci
                  identities or even on the concept of mutual
                  recursion.}
}

@Article{Wirth:2008,
  author   = {Michael Wirth},
  title    = {Introducing recursion by parking cars},
  journal  = {ACM SIGCSE Bull.},
  year     = 2008,
  volume   = 40,
  number   = 4,
  pages    = {52--55},
  month    = dec,
  abstract = {Many approaches to teaching recursion in textbooks
              focus on classical examples such as Fibonacci,
              factorial, or the Towers of Hanoi. As established as
              these algorithms are, they don't really illustrate
              the potential of recursion. This paper explores the
              use of a novel recursive algorithm which requires
              innovative thinking, and the use of random numbers.
              The algorithm looks at the use of recursion to
              randomly park cars on a street.s}
}

@InProceedings{RubioUrquizaPareja:2008,
  author       = {Manuel Rubio-S\'anchez and Jaime Urquiza-Fuentes and
                  Crist\'obal Pareja-Flores},
  title        = {A gentle introduction to mutual recursion},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {235--239},
  year         = 2008,
  month        = jun,
  address      = {Madrid, Spain},
  organization = {ACM \textsc{sigcse-sigcue}},
  note         = {{ISBN} 978-1-60558-078-4},
  abstract     = {Recursion is an important topic in computer science
                  curricula. It is related to the acquisition of
                  competences regarding problem decomposition,
                  functional abstraction and the concept of
                  induction. In comparison with direct recursion,
                  mutual recursion is considered to be more
                  complex. Consequently, it is generally addressed
                  superficially in CS1/2 programming courses and
                  textbooks. We show that, when a problem is
                  approached appropriately, not only can mutual
                  recursion be a powerful tool, but it can also be
                  easy to understand and fun. This paper provides
                  several intuitive and attractive algorithms that
                  rely on mutual recursion, and which have been
                  designed to help strengthen students' ability to
                  decompose problems and apply induction. Furthermore,
                  we show that a solution based on mutual recursion
                  may be easier to design, prove and comprehend than
                  other solutions based on direct recursion. We have
                  evaluated the use of these algorithms while teaching
                  recursion concepts. Results suggest that mutual
                  recursion, in comparison with other types of
                  recursion, is not as hard as it seems when: (1)
                  determining the result of a (mathematical) function
                  call, and, most importantly, (2) designing
                  algorithms for solving simple problems.}
}

@Article{Hsin:2008,
  author   = {Wen-Jung Hsin},
  title    = {Teaching recursion using recursion graphs},
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2008,
  volume   = 23,
  number   = 4,
  pages    = {217--222},
  month    = apr,
  note     = {{ISSN} 1937-4771},
  abstract = {Teaching recursion to undergraduate students is a
              challenging task. In this paper, a Recursion Graph
              is proposed to help students understand the process
              of recursion. Specifically, it provides a visual aid
              to illustrate the concept of recursion.}
}

@Article{Yang:2008,
  author   = {Feng-Jen Yang},
  title    = {Another outlook on linear recursion},
  journal  = {ACM SIGCSE Bull.},
  year     = 2008,
  volume   = 40,
  number   = 4,
  pages    = {38--41},
  month    = dec,
  note     = {{ISSN} 0097-8418},
  abstract = {Recursion is a well known hurdle for computer science
              beginners. This powerful problem solving technique
              challenges both instructors and students on how to
              convey and learn this skill correctively and
              efficiently. In this paper, I presented an analogy-based
              approach to expound the theoretical detail of linear
              recursion.}
}

@InProceedings{ChaffinDoranHicksBarnes:2009,
  author       = {Amanda Chaffin and Katelyn Doran and Drew Hicks and
                  Tiffany Barnes},
  title        = {Experimental evaluation of teaching recursion in a
                  video game},
  booktitle    = {Symposium on Video Games},
  pages        = {79--86},
  year         = 2009,
  address      = {New Orleans, Louisiana, USA},
  month        = aug,
  organization = {ACM \textsc{siggraph}},
  note         = {{ISBN} 978-1-60558-514-7},
  abstract     = {We present EleMental: The Recurrence, a novel game
                  that provides computer science students the
                  opportunity to write code and perform interactive
                  visualizations to learn about recursion through
                  depth-first search of a binary tree. We designed the
                  game to facilitate maximum transfer of learning to
                  writing real programs, while also providing for
                  interactive visualizations. We conducted a study
                  with computer science majors to measure the impact
                  of the game on learning and on attitudes toward
                  educational games. Our results demonstrate the
                  enthusiasm students have for learning games and
                  provide insight into how such games should be
                  constructed.}
}

@InProceedings{GunionMilfordStege:2009a,
  author       = {Katherine Gunion and Todd Milford and Ulrike Stege},
  title        = {Curing recursion aversion},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {124--128},
  year         = 2009,
  month        = jul,
  organization = {ACM \textsc{sigcse-sigcue}},
  address      = {Paris, France},
  note         = {{ISBN} 978-1-60558-381-5},
  abstract     = {This paper outlines a pilot study which expands the
                  age range of students exposed to computer science
                  through interesting and engaging activities. Through
                  this engagement, the number of students who 
                  understood and recognized the concepts covered 
                  increased. We hypothesize that these activities can
                  increase the number of students who pursue 
                  post-secondary computer science. We present a unique 
                  recursion curriculum that exposes nine students aged
                  11-–14 through hands-on experience over a 7 week 
                  period at the University of Victoria, Canada. The 
                  curriculum was comprised of progressively
                  challenging“unplugged” activities and included 
                  programming applications with the Logo-based
                  programming language MicroWorlds EX. Curriculum, 
                  classroom experience, preliminary results and next 
                  steps are discussed.}
}

@Article{GunionMilfordStege:2009b,
  author   = {Katherine Gunion and Todd Milford and Ulrike Stege},
  title    = {The paradigm recursion: {I}s it more accessible when
              introduced in middle school?},
  journal  = {The Journal of Problem Solving},
  year     = 2009,
  volume   = 2,
  number   = 2,
  pages    = {142--172},
  abstract = {Recursion is a programming paradigm as well as a problem
              solving strategy thought to be very challenging to
              grasp for university students. This article outlines
              a pilot study, which expands the age range of
              students exposed to the concept of recursion in
              computer science through instruction in a series of
              interesting and engaging activities. In this study,
              a small number of students (n = 9) aged 11 to 13
              years, were presented with a new and unique
              recursion curriculum involving hands-on experiences
              over a seven-week period at the University of
              Victoria, Canada. The curriculum was comprised of a
              series of progressively challenging recursion
              activities—roughly based upon the ideas of ‘Computer
              Science Unplugged’ (Bell, Witten, & Fellows,
              2009)—and included programming applications with
              MicroWorlds EX, a programming language based on
              LOGO. Through this engagement, an increased number
              of students recognized and understood the concepts
              covered. We hypothesize that through experiences for
              youth with activities such as those outlined here,
              the number of students who understand fundamental
              computer science applications and who might
              potentially pursue computer science in
              post-secondary education will increase. We
              hypothesis further that through an earlier encounter
              of “challenging” concepts the learning and
              understanding of those will become easier at the
              university level. In this paper, the curriculum,
              classroom experiences, preliminary, largely
              descriptive and qualitative results and next steps
              in the research are discussed.}
}

@comment Animation as an aid to learn programming

@Article{WilcoksSanders:1994,
  author   = {Derek Wilcocks and Ian Sanders},
  title    = {Animating recursion as an aid to instruction},
  journal  = {Computers \& Education},
  year     = 1994,
  volume   = 23,
  number   = 3,
  pages    = {221--226},
  month    = nov,
  note     = {{ISSN} 0360-1315},
  abstract = {Discussion of how to teach programming skills to novice
              programmers focuses on the use of a program animator
              that uses a copies model of recursion to teach the
              recursive function. Various mental models are
              reviewed; testing the recursion animator is
              described; and possibilities for further research
              are suggested.}
}

@Article{SternNaish:2002a,
  author   = {Linda Stern and Lee Naish},
  title    = {Animating recursive algorithms},
  journal  = {Interactive Multimedia Electronic Journal of
              Computer\hyp{}Enhanced Learning},
  year     = 2002,
  volume   = 4,
  number   = 2,
  month    = oct,
  abstract = {Designing visual representations for recursive
              algorithms has been addressed within a
              pedagogically-oriented framework for animating
              algorithms. We present a classification for choosing
              the kind of visual representation that is most
              helpful to students. The classification is based on
              the way the algorithm navigates through a data
              structure and manipulates data items within a data
              structure, and suggest strategies for visual
              representation that work within the categories of
              this classification. Further opportunities for
              tailoring representation derive from the shape of
              the data structure and particular forms of
              recursion, such as tail recursion. While there may
              be no single, general way to represent recursive
              algorithms, our classification is a useful guide to
              picking an appropriate strategy for use when
              animating recursive algorithms for teaching
              purposes.}
}

@InBook{FernandezPerezVelazquezUrquiza:2007,
  author    = {Luis Fern\'andez-Mu\~noz and Antonio
               P\'erez-Carrasco and J. \'Angel Vel\'azquez-Iturbide
               and Jaime Urquiza-Fuentes},
  title     = {Creating new learning experiences on a global scale},
  chapter   = {A framework for the automatic generation of
               algorithm animations based on design techniques},
  publisher = {Springer},
  year      = 2007,
  volume    = 4753,
  series    = {LNCS 4753},
  pages     = {475–-480},
  note      = {{ISBN} 978-3-540-75194-6},
  abstract  = {A novel approach to algorithm animation consists in
               displaying algorithms based on their design
               technique. In this paper, we describe a framework to
               generate these animations without effort from the
               instructor. We describe a preprocessing phase that
               modifies the source code of the algorithm to
               visualize. When the transformed code is executed, a
               trace is stored and then used to gen- erate an
               animation. We also describe the architecture of the
               animation subsystem. Finally, we outline the main
               features of SRec, a system that we have built to
               illustrate the feasibility of this approach. It is
               aimed at visualizing multiple views of recursion,
               namely traces, the control stack and activation
               trees.}
}

@InProceedings{VelazquezPerezUrquiza:2008,
  author       = {J. \'Angel Vel\'azquez-Iturbide and Antonio
                  P\'erez-Carrasco and Jaime Urquiza-Fuentes},
  title        = {{SRec}: {A}n animation system of recursion for
                  algorithm courses},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {225--229},
  year         = 2008,
  month        = jun,
  address      = {Madrid, Spain},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 978-1-60558-078-4},
  abstract     = {In this paper we describe SRec, a system to animate
                  recursion in Java programs. It is intended to assist
                  in algorithm courses to better understand and
                  analyze algorithm behavior. We make several
                  contributions. Firstly, SRec exhibits a
                  comprehensive set of animation and educational
                  features. It provides three complem- entary,
                  coordinated views of recursion: traces, the
                  execution stack and activation trees. SRec allows
                  the user constructing and modifying animations
                  without effort. The animation can be played
                  flexibly, both forward and backwards. It also
                  provides facilities to integrate animations into
                  courses. Secondly, the paper describes the
                  educational features of the system and its use in
                  algorithm courses. Thirdly, the system has been
                  fully evaluated with respect to usability (using
                  formative and summative methods) and has been
                  compared to other systems reported in the
                  literature. The results of both evaluations are
                  highly positive.}
}

@InProceedings{VelazquezCarrascoaUrquiza:2008,
  author    = {J. \'Angel Vel\'azquez-Iturbidea and Antonio
               P\'erez-Carrascoa and Jaime Urquiza-Fuentes},
  title     = {A design of automatic visualizations for
               divide\hyp{}and\hyp{}conquer algorithms},
  booktitle = {Program Visualization Workshop},
  pages     = {159--167},
  year      = 2009,
  volume    = 224,
  series    = {Electronic Notes in Theoretical Computer Science},
  month     = jan,
  abstract  = {The paper addresses the design of program
               visualizations adequate to represent
               divide-and-conquer algorithms. Firstly, we present
               the results of several surveys performed on the
               visualization of divide-and-conquer algorithms in
               the literature. Secondly, we make a proposal for
               three complementary, coordinated views of these
               algorithms. In summary, they are based an animation
               of the activation tree, an animation of the data
               structure, and a sequence of visualizations of the
               substructures, respectively.}
}

@Article{VelazquezPerez:2010,
  author   = {J. \'Angel Vel\'azquez-Iturbide and Antonio P\'erez-Carrasco},
  title    = {{InfoVis} interaction techniques in animation of
              recursive programs},
  journal  = {Algorithms},
  year     = 2010,
  volume   = 3,
  number   = 1,
  pages    = {76--91},
  note     = {{ISSN} 1999-4893},
  abstract = {Algorithm animations typically assist in educational
              tasks aimed simply at achieving understanding. 
              Potentially, animations could assist in higher levels 
              of cognition, such as the analysis level, but they 
              usually fail in providing this support because they are 
              not flexible or comprehensive enough. In particular, 
              animations of recursion provided by educational systems 
              hardly support the analysis of recursive algorithms. Here
              we show how to provide full support to the analysis of 
              recursive algorithms. From a technical point of view, 
              animations are enriched with interaction techniques 
              inspired by the information visualization (InfoVis)
              field. Interaction tasks are presented in seven
              categories, and deal with both static visualizations and 
              dynamic animations. All of these features are
              implemented in the SRec system, and visualizations 
              generated by SRec are used to illustrate the article.}
}

@comment Visualization as an aid to learn programming

@InProceedings{ChuJohnsonbaugh:1987,
  author       = {I-Ping Chu and Richard Johnsonbaugh},
  title        = {Tiling and recursion},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {261--263},
  year         = 1987,
  month        = feb,
  address      = {St. Louis, Missouri, USA},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 0-89791-217-9},
  abstract     = {A tiling problem is presented that demonstrates the
                  power of recursion in the design of algorithms. When
                  implemented as a program, the solution can be shown
                  using a computer graphics display}
}

@Article{Wakin:1989,
  author  = {Shirley Wakin},
  title   = {Proof without words: {R}ecursion},
  journal = {Mathematics Magazine},
  year    = 1989,
  volume  = 62,
  number  = 3,
  pages   = {172--172},
  month   = jun
}

@InProceedings{Moreno:1992,
  author       = {Luis Moreno Armella},
  title        = {Visualizaci\'on y recursividad: {U}n enfoque computacional},
  booktitle    = {Congreso Iberoamericano de Inform\'atica Educativa},
  year         = 1992,
  address      = {Santo Domingo, Dominican Republic},
  month        = jun,
  organization = {CYTED/RIBIE},
  abstract     = {La pantalla de la computadora suministra un ambiente
                  donde la interacción entre lo visual y lo simbólico 
                  puede ser aprovechada para que el estudiante, a
                  través de actividades diseñadas por el profesor, 
                  (re)-produzca el conocimiento matemático pertinente.
                  Esta producción está íntimamente vinculada a la 
                  gestación de un contexto, al interior del cual se
                  organizan los significados matemáticos. La
                  computadora permite, al ejecutar el código que 
                  "captura" un algoritmo, la exteriorización del 
                  conocimiento del estudiante. Esto posibilita la
                  reflexión del estudiante sobre sus acciones mentales
                  y el proceso de socialización del conocimiento. En
                  este artículo se propone la exploración, mediantes
                  la gráficación, de los procesos recursivos, en el 
                  contexto suministrado por un enfoque constructivista
                  de la educación matemática.}
}

@InProceedings{George:1995,
  author    = {Carlisle Eldwidge George},
  title     = {Supporting the learning of recursion},
  booktitle = {Annual Conf. on the Teaching of Computing},
  year      = 1995,
  address   = {Dublin City University, Ireland},
  month     = aug
}

@InProceedings{HuiIverson:1995,
  author       = {Roger K. W. Hui and Kenneth E. Iverson},
  title        = {Representations of recursion},
  booktitle    = {Intl. Conf. on Applied Programming Languages},
  pages        = {91--97},
  year         = 1995,
  month        = jun,
  address      = {San Antonio, Texas, USA},
  organization = {ACM \textsc{sigapl}},
  note         = {{ISBN} 0-89791-722-7}
}

@Article{GoodBrna:1996,
  author    = {Judith Good and Paul Brna},
  title     = {Scaffolding for recursion; can visual languages help?},
  publisher = {The Institution of Electrical Engineers},
  year      = {1996},
  journal   = {IEE Seminar Digests},
  volume    = {10},
  number    = {7},
  pages     = {1--3}
}

@Article{WeiMurray:2008,
  author   = {Xiaoming Wei and Keitha Murray},
  title    = {A detail+context approach to visualize function calls},
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2008,
  volume   = 23,
  number   = 3,
  pages    = {162--167},
  month    = jan,
  note     = {{ISSN} 1937-4771},
  abstract = {We present our work using a hyperbolic tree structure to
              animate program function calls and use it as an
              alternative method to demonstrating concepts such as
              recursion. Our main goal is to develop a visualization 
              tool to help both lower level and upper level computer 
              science students understand the trace of a function
              call. A detailed visualization of a function call,
              including the assignment of variables, allocation of 
              memory, execution of control statements, etc. can help 
              lower level students understand the underlying data 
              structures and algorithms. At the same time, a global 
              view of the hierarchical call chain can provide greater
              insight for upper level students. We propose the
              utilization of the hyperbolic tree as a tool for
              visualizing larger and more complex Java programs.}
}

@InProceedings{George:2000b,
  author    = {Carlisle Eldwidge George},
  title     = {{EROSI} - {V}isualizing recursion and discovering new
               errors},
  booktitle = {ACM SIGCSE Conf.},
  pages     = {305--309},
  year      = 2000,
  month     = mar,
  volume    = 32,
  address   = {Austin, Texas, USA},
  note      = {{ISSN} 0097-8418},
  abstract  = {This paper introduces a novel software visualisation
               aid, the EROSI (Explicit Representer Of Subprogram
               Invocations) tutor, hypothesised to support the
               acquisition (by novice programmers) of a mental
               model to facilitate the comprehension and use of
               recursion as a problem solving technique. Novices
               found the EROSI tutor easy to use, interesting and a
               valuable visualisation aid to forming correct mental
               models of recursive processes. Studies concluded
               that although novices many have a correct mental
               model of recursion, various errors and
               misconceptions (identified) due to exogenous factors
               affect their ability to complete recursive tasks.}
}

@InProceedings{VelazquezPerezUrquiza:2009,
  author       = {J. \'Angel Vel\'azquez-Iturbide and Antonio
                  P\'erez-Carrasco and Jaime Urquiza-Fuentes},
  title        = {Interactive visualization of recursion with {SRec}},
  booktitle    = {Conf. on Innovation and Technology in Comp. Sci. Education},
  pages        = {339--339},
  year         = 2009,
  month        = jul,
  address      = {Paris, France},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 978-1-60558-381-5},
  abstract     = {SRec is an animation system of recursion intended to
                  assist in algorithm courses. We present the main
                  contributions of version 1.1. First, SRec fully
                  supports any kind of recursion. Second, it provides
                  three additional graphical representations for
                  divide-and-conquer algorithms. Finally, it is highly
                  interactive to promote an exploratory style of
                  learning.}
}

@InProceedings{Rosenthal:2005,
  author       = {Tammy Rosenthal},
  title        = {Introducing recursion by using multimedia},
  booktitle    = {Conf. on Innovation and Technology in Comp. Sci. Education},
  pages        = {374--374},
  year         = 2005,
  month        = jun,
  address      = {Caparica, Portugal},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-59593-024-8}
}

@Article{Stephenson:2009b,
  author   = {Ben Stephenson},
  title    = {Using graphical examples to motivate the study of recursion},
  journal  = {The Journal of Computing Sciences in Colleges},
  year     = 2009,
  volume   = 25,
  number   = 1,
  pages    = {42--50},
  month    = oct,
  note     = {{ISSN} 1937-4771},
  abstract = {Recursion is an important part of a complete computer
              science education. It is a topic that is often
              introduced during the first course, and then
              revisited when tree data structures are introduced
              and functional languages are discussed. Because
              recursion is introduced early in the curriculum, the
              range of problems that can be discussed when it is
              first encountered is limited. In particular, because
              students generally haven't been introduced to data
              structures like trees or efficient sorting
              algorithms such as quick sort and merge sort, these
              areas which use recursion to elegantly solve
              important problems can't be used to motivate its
              study.  This paper describes three graphical
              problems which can be used to motivate the study of
              recursion. Each of the examples demonstrates the
              utility of recursion while being appropriate for
              students nearing the end of their first term in a
              computer science course. In particular, these
              examples can be understood and implemented by
              students who have a reasonable understanding of
              loops, function calls, and, for some problems,
              arrays. They do not require any knowledge of object
              oriented design, pointers or complex data
              structures. Furthermore, while iterative solutions
              exist for each of the problems that we describe, the
              iterative solution for each problem is more complex
              than its recursive solution. We believe that this is
              an additional strength of these examples because it
              helps convince students that recursion is a tool
              that will allow them solve some problems more easily.}
}

@InProceedings{DannCooperPausch:2001,
  author       = {Wanda Dann  and Stephen Cooper and Randy Pausch},
  title        = {Using visualization to teach novices recursion},
  booktitle    = {Conf. on Innovation and Technology in Comp. Sci. Education},
  pages        = {109--112},
  year         = 2001,
  address      = {Canterbury, United Kingdom},
  month        = jun,
  organization = {ACM \textsc{sigcse/sigcue}},
  note         = {{ISBN} 1-58113-330-8},
  abstract     = {This paper describes an approach for introducing
                  recursion, as part of a course for novice
                  programmers. The course is designed to make use of a
                  3-D animation world-builder as a visualization tool
                  that allows students to see their own programs in
                  action. One of the pedagogical goals of the course
                  is to enable the student to gain an intuitive sense
                  of and mathematical insight into the recursive
                  process. The software, examples of animation using
                  recursion, and some experiences in using this
                  approach are discussed.}
}

@InProceedings{Stephenson:2009a,
  author       = {Ben Stephenson},
  title        = {Visual examples of recursion},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {400--400},
  year         = 2009,
  address      = {Paris, France},
  month        = jul,
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 978-1-60558-381-5},
  abstract     = {Because recursion is generally introduced early in
                  the curriculum, the range of problems that can be
                  used to motivate its study is limited. We describe
                  three interesting visual problems that use recursion
                  effectively. Each problem demonstrates the utility
                  of recursion in an engaging way while being
                  appropriate for students nearing the end of CS1.}
}

@InProceedings{WuLeeMei:1998,
  author       = {Chen-Chih Wu and Greg C. Lee and Janet Mei-Chuen Lin},
  title        = {Visualizing programming in recursion and linked lists},
  booktitle    = {Australasian Conf. on Comp. Sci. Education},
  pages        = {180--186},
  year         = 1998,
  volume       = 3,
  series       = {ACM Intl. Conf. Proc.},
  address      = {University of Queensland, Australia},
  month        = jul,
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-018-X},
  abstract     = {In this paper we present the new versions of two
                  software packages, SimLIST and SimRECUR. The new
                  user interface and the added visualizing programming
                  feature of the software are described. Closed-lab 
                  exercise using SimLIST was conducted to better
                  understand the suitability of using such software as
                  visualization tools. The results of a survey after
                  the lab exercise give indications that this hands-on
                  approach to learning abstract concepts is a step in
                  the right direction.}
}

@InProceedings{BurnettRenKoCookRothermel:2001,
  author    = {Margaret Burnett and Bing Ren and Andrew Ko and
               Curtis Cook and Gregg Rothermel},
  title     = {Visually testing recursive programs in spreadsheet
               languages},
  booktitle = {IEEE Symposia on Human\hyp{}Centric Computing
               Languages and Environments},
  year      = 2001,
  address   = {Stresa, Italy},
  month     = sep,
  abstract  = {Although there has been recent research into ways to
               design visual programming languages and
               environments, little attention has been given to
               systematic testing in these languages, and what work
               has been done does not address "power" features
               such as recursion. In this paper, we discuss two
               possible ways the "What You See Is What You Test"
               methodology could be extended to accommodate
               recursion. The approaches are presented in terms of
               their testing theoretic aspects and then
               implementation strategies and algorithms. Since the
               goal is to help the people using these languages, we
               also present an empirical study and use its results
               to inform our choice as to which of the two
               approaches to adopt.}
}

@Article{TungChangWongJehng:2001,
  author   = {Sho-Huan Tung and Ching-Tao Chang and Wing-Kwong
              Wong and Jihn-Chang Jehng },
  title    = {Visual representations for recursion},
  journal  = {Intl. Journal of Human\hyp{}Computer Studies},
  year     = 2001,
  volume   = 54,
  number   = 3,
  pages    = {285--300},
  month    = mar,
  note     = {{ISSN} 1071-5819},
  abstract = {Visualcode is a visual notation that uses coloured
              expressions and graphical environ- ments to describe
              the execution of Scheme programs. RainbowScheme is a
              program visualization system which is designed to
              produce visualcode representations of step-by-step
              execution of Scheme programs. This article presents
              a new approach of teaching recursion using
              visualcode and RainbowScheme. Experimental
              evaluation indicates that viewing
              RainbowScheme-produced visual traces and requiring
              students to use visualcode to generate visual
              evaluation steps of recursive programs can enhance
              the learners' ability to evaluate recursive programs
              as well as to solve recursive programming problems.}
}

@InProceedings{SternNaish:2002b,
  author       = {Linda Stern and Lee Naish},
  title        = {Visual representations for recursive algorithms},
  booktitle    = {Technical Symp. on Comp. Sci. Education},
  pages        = {196--200},
  year         = 2002,
  address      = {Cincinnati, Kentucky, USA},
  month        = feb,
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-473-8},
  abstract     = {We have developed a framework for
                  pedagogically-oriented animations, designed to help
                  students learn new algorithms. Recursive sorting and
                  searching algorithms pose a particular challenge, as
                  it can be difficult to find visual representations
                  that help students develop a mental model of how the
                  recursion proceeds. Relatively complex
                  representations, such as thumbnail sketches or
                  explicitly showing the function stack along with the
                  data structure are appropriate for some algorithms,
                  while simpler representations suffice for others. We
                  have found it useful to classify recursive
                  algorithms according to the way they navigate
                  through a data structure and manipulate data items
                  within it, sometimes with further subdivision
                  according to the kind of recursion. Within each
                  category there are common strategies for visual
                  representation. While there may be no single,
                  general way to represent recursive algorithms,
                  classification is a useful guide to picking an
                  appropriate strategy when animating recursive
                  algorithms.}
}

@Article{HundhausenFarleyBrown:2009,
  author   = {Christopher D. Hundhausen and Sean F. Farley and
              Jonathan L. Brown},
  title    = {Can direct manipulation lower the barriers to
              computer programming and promote transfer of
              training? {A}n experimental study},
  journal  = {ACM Trans. on Computer\hyp{}Human Interaction},
  year     = 2009,
  volume   = 16,
  number   = 3,
  month    = sep,
  note     = {{ISSN} 1073-0516},
  abstract = {Novices face many barriers when learning to program a
              computer, including the need to learn both a new
              syntax and a model of computation. By constraining
              syntax and providing concrete visual representations
              on which to operate, direct manipulation programming
              environments can potentially lower these
              barriers. However, what if the ultimate learning
              goal of the novice is to be able to program in
              conventional textual languages, as is the case for
              introductory computer science students? Can direct
              manipulation programming environments lower the
              initial barriers to programming, and, at the same
              time, facilitate positive transfer to textual
              programming? To address this question, we designed
              a new direct manipulation programming interface for
              novices, and conducted an experimental study to
              compare the programming processes and outcomes
              promoted by the direct manipulation interface
              against those promoted by a textual programming
              interface. We found that the direct manipulation
              interface promoted significantly better initial
              programming outcomes, positive transfer to the
              textual interface, and significant differences in
              programming processes. Our results show that direct
              manipulation interfaces can provide novices with a
              “way in” to traditional textual programming.}
}


@comment Miscellanea

@InProceedings{Schiemenz:2002,
  author    = {Bernd Schiemenz},
  title     = {Managing complexity by recursion},
  booktitle = {Symposium on Management and Organizational Change at
               the European Meeting on Cybernetics and Systems
               Research},
  year      = 2002,
  address   = {Vienna, Austria},
  month     = apr,
  abstract  = {Recursion is a well known concept within computer
               science and mathematics. In business management it
               is rarely used explicitly. Counterexamples are
               applications of dynamic programming and the `Viable
               System´ of Stafford Beer (1972). This paper
               demonstrates the broad applicability of recursion to
               managing complexity, especially in business. It
               starts by showing that recursion is–-in contrast to
               how it may appear in papers of e.g. H.A.Simon
               (1973)-–a special case of (intrasystems-)hierarchy. It 
               shows the two different yet related forms of using 
               recursion: recursive objects and recursive problem
               solving and gives general examples of both. It then 
               focuses on recursive objects and problem solving in 
               business and finally summarizes the advantages of 
               recursion.}
}

@InProceedings{Bampton:1998,
  author    = {Alvin Bampton},
  title     = {Teaching computer science in {P}apua {N}ew {G}uinea},
  booktitle = {Joint Conf. on Integrating Technology into
               Comp. Sci. Education},
  pages     = {25--27},
  year      = 1998,
  address   = {Dublin City University, Ireland},
  month     = aug,
  publisher = {ACM \textsc{sigcse/sigcue}},
  note      = {{ISBN} 1-58113-000-7},
  abstract  = {This paper introduces some observed sociological and
               cultural aspects of students. It is usually assumed
               that these aspects are the same as the lecturer's
               own, but that is not necessarily so, here in Papua
               New Guinea. Assignments to encourage both the change
               of attitude and for the practice of the technical
               content of courses are described.}
}

@comment Functional and Logic programming

@InProceedings{Brown:1972,
  author       = {John Seely Brown},
  title        = {Recursive functional programming as a conceptual
                  tool for social scientists},
  booktitle    = {ACM Annual Conf.},
  pages        = {320--320},
  year         = 1972,
  month        = aug,
  volume       = 1,
  address      = {Boston, Massachusetts, USA},
  organization = {ACM \textsc{sigcue}}
}

@Article{Hudak:1989,
  author   = {Paul Hudak},
  title    = {Conception, evolution, and application of
              functional programming languages},
  journal  = {ACM Computing Surveys},
  year     = 1989,
  volume   = 21,
  number   = 3,
  pages    = {359--411},
  month    = sep,
  note     = {{ISSN} 0360-0300},
  abstract = {The foundations of functional programming languages 
              are examined from both historical and technical
              perspectives. Their evolution is traced through
              several critical periods: early work on lambda
              calculus and combinatory calculus, Lisp, Iswim, FP,
              ML, and modern functional languages such as Miranda
              and Haskell. The fundamental premises on which the
              functional programming methodology stands are
              critically analyzed with respect to philosophical,
              theoretical, and pragmatic concerns. Particular
              attention is paid to the main features that
              characterize modern functional languages:
              higher-order functions, lazy evaluation, equations
              and pattern matching, strong static typing and type
              inference, and data abstraction. In addition,
              current research areas—such as parallelism,
              nondeterminism, input/output, and state-oriented
              computations—are examined with the goal of
              predicting the future development and application of
              functional languages.}
}

@Article{Hughes:1989,
  author   = {John Hughes},
  title    = {Why functional programming matters},
  journal  = {The Computer Journal},
  year     = 1989,
  volume   = 32,
  number   = 2,
  pages    = {98--107},
  month    = apr,
  note     = {{ISSN} 0010-4620},
  abstract = {As software becomes more and more complex, it is more
              and more important to structure it
              well. Well-structured software is easy to write,
              easy to debug, and provides a collection of modules
              that can be reused to reduce future programming
              costs. Conventional languages place con- ceptual
              limits on the way problems can be
              modularised. Functional languages push those
              limits back. In this paper we show that two features
              of functional languages in particular, higher-order
              functions and lazy evaluation, can contribute
              greatly to modularity. As examples, we manipulate
              lists and trees, program several numerical
              algorithms, and implement the alpha-beta heuristic
              (an algorithm from Artificial Intelligence used in
              game-playing programs). Since modularity is the key
              to successful programming, functional languages
              are vitally important to the real world.}
}

@InBook{Harvey:1992,
  author    = {Brian Harvey},
  title     = {Learning mathematics and {L}ogo},
  chapter   = {Avoiding recursion},
  publisher = {The MIT Press},
  year      = 1992,
  address   = {Cambridge, Massachusetts, USA},
  pages     = {393--426},
  note      = {{ISBN} 0-262-08207-1}
}

@Article{Segal:1994,
  author   = {Judith Segal},
  title    = {Empirical studies of functional programming
              learners evaluating recursive functions},
  journal  = {Instructional Science},
  year     = 1994,
  volume   = 22,
  number   = 5,
  pages    = {385--411},
  month    = sep,
  note     = {{ISSN} 0020-4277},
  abstract = {In this paper, we report some empirical studies of
              students evaluating recursive functions defined
              according to the rules of the functional programming
              language Miranda, and describe the misconceptions
              and processing strategies observed. We then discuss
              the implications of these observations as regards
              teaching content.}
}

@InProceedings{ClakMyers:1995,
  author    = {Chris D. Clack and Colin Myers},
  title     = {The dys\hyp{}functional student},
  booktitle = {Intl. Symp. on Functional Programming Lang. in
               Education},
  pages     = {289--309},
  year      = 1995,
  number    = 1022,
  series    = {LNCS},
  publisher = {Springer-Verlag, London, UK},
  note      = {{ISBN} 3-540-60675-0},
  abstract  = {Functional languages liberate students from complex
               syntax, complex semantics and complex memory
               allocation; allowing them to concentrate on
               problen-solving. However, functional programming is not
               a panacea. Students still have problems with languages 
               features, program concepts and the legacy of the
               imperative paradigm. This paper aims to assist the
               lecturer asked to teach a functional language for the 
               first time. We present typical student mistakes, 
               attempt to explain why these mistakes arise, and
               propose possible remedies.}
}

@InBook{Burton:1995,
  author    = {C T Peter Burton},
  title     = {Functional programming languages in education},
  chapter   = {Conceptual structures for recursion},
  publisher = {Springer},
  year      = 1995,
  volume    = 1022,
  series    = {Lecture Notes in Computer Science},
  note      = {{ISSN} 0302-9743},
  abstract  = {Consideration will be given to the perplexity students
               experience with recursive function definitions.
               Certain conceptual structures will be suggested,
               which might provide a path through the thicket. In
               particular, emphasis will be placed on decisions
               that a programmer makes during the course of
               designing a recursive definition. By drawing
               attention to these decisions—-by classifying them
               and making them explicit-—it is possible to
               delineate the kind of "space" within which
               creativity operates. To vivify this, a rudimentary
               taxonomy of recursive function definitions will be
               sketched here. It will be illustrated in a
               particular application area, involving a family of
               simple string-processing tasks. This will highlight
               two different kinds of structure: (i) classification
               of different tasks within the family, (ii)
               classification of different approaches to a single
               task. Some of the points to be raised are not
               specific to recursion; accordingly, connections will
               be drawn here and there with certain more general
               pedagogical themes promulgated by Peter Landin in
               recent years.}
}

@PhdThesis{Kelso:2002,
  author  = {Joel Kelso},
  title   = {A visual programming environment for functional languages},
  school  = {Murdoch University},
  year    = 2002,
  address = {Perth, Australia}
}

@InProceedings{daRosa:2002,
  author    = {Sylvia da Rosa},
  title     = {The role of discrete mathematics and programming in
               education},
  booktitle = {International Workshop on Functional and Declarative
               Programming in Education},
  year      = 2002,
  address   = {Pittsburgh, Pennsylvania, USA},
  month     = oct,
  publisher = {Technical Report 0210, Univ. of Kiel},
  abstract  = {We have been teaching introductory courses on Functional
               Programming, as part of the curricula of computer
               science university studies, for several years. We
               claim that the origin of most of the difficulties
               in learning Functional Programming doesn't lie in
               computer science courses but in the mathematical
               background of the students. We are convinced that an
               integrated work of mathematics and computer science
               educators will considerably benefit the learning of
               both subjects. Our proposal mainly consists in
               formulating a new approach to teach discrete
               mathematics topics included in High School
               mathematics curricula, relating them with computer
               science concepts. This implies to increase the
               dedication to discrete mathematics in High School
               curricula and to introduce a programming language as
               a formalism to manipulate the mathematical
               objects. We include examples of a course in Discrete
               Mathematics using the programming language ISETL
               that we taught to a group of High School mathematics
               teachers.}
}

@InProceedings{PazLapidot:2004,
  author       = {Tamar Paz and Tami Lapidot},
  title        = {Emergence of automated assignment conceptions in a
                  functional programming course},
  booktitle    = {Conf. on Innovation and Technology in
                  Comp. Sci. Education},
  pages        = {181--185},
  year         = 2004,
  month        = jun,
  address      = {Leeds, United Kingdom},
  organization = {ACM \textsc{sigcse}},
  note         = {{ISBN} 1-58113-836-9},
  abstract     = {This paper reports a research into the performance
                  of high school students while they were first
                  exposed to the paradigm of functional
                  programming. The findings have been organized using
                  three categories. In this paper we will concentrate
                  on the "Automated assignment to parameters"
                  conception which was the most widespread conception
                  found in the research. We will describe the
                  conception and will discuss some possible factors
                  that could influence its development.}
}

@comment Textbooks

@Book{FelleisenFriedman:1997,
  author    = {Matthias Felleisen and Daniel P. Friedman},
  title     = {A little {J}ava, a few patterns},
  publisher = {The MIT Press},
  year      = 1997,
  month     = dec,
  note      = {{ISBN} 0-262-56115-8}
}

@Article{JarviPowellLumsdaine:2003,
  author  = {Jaakko J\"arvi and Gary Powell and Andrew Lumsdaine},
  title   = {The {L}ambda library: unnamed functions in \cpp},
  journal = {Software--Practice \& Experience},
  year    = 2003,
  volume  = 33,
  number  = 3,
  pages   = {259--291},
  month   = mar,
  note    = {{ISSN} 0038-0644}
}

@Book{VanRoyHariri:2004,
  author    = {Peter Van Roy and Seif Hariri},
  title     = {Concepts, {T}echniques, and {Models} of {C}omputer
               {P}rogramming},
  publisher = {The MIT Press},
  year      = 2004,
  note      = {{ISBN} 0-262-22069-5}
}

@Book{Dominus:2005,
  author    = {Mark Jason Dominus},
  title     = {Higher {O}rder {P}erl},
  publisher = {Elsevier},
  year      = 2005,
  note      = {{ISBN}-13: 978-1-55860-7019}
}

@Book{CLRS:2009,
  author    = {Thomas Cormen and Charles Leiserson and Ronald
               Rivest and Clifford Stein},
  title     = {Introduction to {A}lgorithms},
  publisher = {The MIT Press},
  year      = 2009,
  note      = {{ISBN} 978-0-262-03384-8}
}
