TODO: For each test case, you need to think and specify what you want to measure and what is expected. With this process, you will easily know in which area test cases are missing and in which area it is redundant. 

REVERSE.


Reverse the items in a list.

The user will start the interaction by setting 2 lists on the table
one containing an empty list used for temporary transactions (called from now on Tmp) and
the other containing a list with at least 2 items(called from now on L), less than 2 items would
not do an interesting problem.

This is a very simple problem where the user only have
to move the items from L to Tmp, once L is empty the user has to mark
Tmp as the return value

The Erlang code representation of this problem is the following:

reverse(          [],Tmp) -> Tmp;
reverse([TopL|RestL],Tmp) -> reverse(RestL,[TopL|Tmp]).

================================================================================
================================================================================

JOIN

Join the items of two lists into a new list

The user will start the interaction by setting 3 lists on the table, two of these
lists must contain at least 2 items (called from now on L1 and L2 respectively)
and the other list must be empty (called from now on Tmp).

The solution to this problem is to move one by one the items from L1 to Tmp, once
in Tmp these items will be in reversed order because we did pop from L1 and push
into Tmp, these items must be moved again from Tmp but this time into L2 the
items will be in the original order has they were in L1 but this time will be
on top of L2 items, L2 will contain the solution to the problem

This code is the erlang version of the previous procedure:

join(             Tmp,[TopL1|RestL1],L2) -> join([TopL1|Tmp], RestL1, L2);
join([TopTmp|RestTmp],            [],L2) -> join(RestTmp, [], [TopTmp|L2]);
join(              [],            [],L2) -> L2.

This is an example interaction of a student using the interface:

This is the initial state:

Legend:

|&|: is the return block, anything below it points to the final return
value of the function
|X|: is a block that represents an item which value is X (a constant value)
|-|: is a block that represents a list
(L): is the name of the list, is shown only to ease the understanding of
this example, in the real interface this is not visible

L1 contains 3 items (A, B and C) and L2 contains 2(D and E), Tmp is an empty list,

State 1:

           |C|
      |E|  |B|
      |D|  |A|
|-|   |-|  |-|
(Tmp) (L1) (L2)


The user start moving the items from L1 into Tmp, State 2 and 3 represents
the first rule of the erlang code:

join(Tmp,[TopL1|RestL1],L2) -> join([TopL1|Tmp], RestL1, L2);


State 2:

           |C|
           |B|
|E|   |D|  |A|
|-|   |-|  |-|
(Tmp) (L1) (L2)

State 3:

           |C|
|D|        |B|
|E|        |A|
|-|   |-|  |-|
(Tmp) (L1) (L2)


When L1 is empty is time to move the items from Tmp into L2, State 4 and 5 represents
the second rule of the erlang code:

join([TopTmp|RestTmp],[],L2) -> join(RestTmp, [], [TopTmp|L2]);

State 4:
           
           |D|
           |C|
           |B|
|E|        |A|
|-|   |-|  |-|
(Tmp) (L1) (L2)

State 5:

           |E|
           |D|
           |C|
           |B|
           |A|
|-|   |-|  |-|
(Tmp) (L1) (L2)

And, to finilize the problem, the user points at the return value, this state represents
the last rule in the erlang code:

join([],[],L2) -> L2.

State 6
           |&|
           |E|
           |D|
           |C|
           |B|
           |A|
|-|   |-|  |-|
(Tmp) (L1) (L2)

================================================================================
================================================================================

REMOVEALL

Remove all the appearances of a value in a list

The user begins by setting 4 blocks on the table, a list with at least 2 elements
(called from now on L) and two temporary lists (called from now on Tmp1 and Tmp2)
and finally an item that will represent the value to be removed from the list (called
from now on E)

The second step is to move the items from L into Tmp2, one conditions has to be
considered before moving the items though, when the item of L is equal to E the
Item has to be removed from the table instead of moved to Tmp2.

Once all the items from L are in Tmp2 the user has to move them again into Tmp1
to revert the items into their original order, when this step is done the result
value will be the list Tmp1.

The Erlang code representation of this problem is the following:

rem_all(E,Tmp1,              Tmp2,   [E|RestL]) -> rem_all(E,Tmp1,Tmp2,RestL);
rem_all(E,Tmp1,              Tmp2,[TopL|RestL]) -> rem_all(E,Tmp1,[TopL|Tmp2],RestL);
rem_all(E,Tmp1,[TopTmp2|RestTmp2],          []) -> rem_all(E,[TopTmp2|Tmp1],RestTmp2,[]);
rem_all(E,Tmp1,                [],          []) -> Tmp1.

================================================================================
================================================================================

COMPRESS.

Remove the repeating consecutive items in a list.

This exercise is very similar to the REMOVEALL exercise, the only two differences are
first, the initial setting does not contains an independent item (E), the second
difference is that in the second step instead of comparing the Item of L against E
we will compare it this time against the top item of Tmp2.

The Erlang code representation of this problem is the following:

compress(Tmp1,   [TopL|RestTmp2],[TopL|RestL]) -> compress(Tmp1,RestTmp2,[TopL|RestL]);
compress(Tmp1,              Tmp2,[TopL|RestL]) -> compress(Tmp1,[TopL|Tmp2],RestL);
compress(Tmp1,[TopTmp2|RestTmp2],          []) -> compress([TopTmp2|Tmp1],RestTmp2,[]);
compress(Tmp1,                [],          []) -> Tmp1.

================================================================================
================================================================================

INSERTION SORT.

Sort the items in a list in ascending order.

Sorting is a very well known problem, it is used in many computing areas and
studied at least once in their lifes by every computer scientist around the
world.

The problem consists on putting the items of a list in a given order, for
simplicity in our experiment we are going to focus on ascending numerical order
using the insertion sort algorithm.

In a computing context this algorithm is probably not the most optimum but it
surely is the most suitable for functional programming beginners because it
allows to get acquainted and at the same time understand how sorting problems
could be solved without getting into the complications of other solutions such
as quick sort (as a personal comment, quicksort is a little hard to understand,
when I saw it for the first time I thought it was magic running on my computer)

On insertion sort the user will remove an item from the input list to insert it
in the correct position into the output list which will always be consistently
ordered, once the input list is out of items this list will contains the
solution.

Inserting an item into a list is a very tedious action that requires first to
pop out all the elements on top of the desired location, then push the item in
the top of the list and the push back the removed items, because of this for
practical purposes we will use 2 temporary lists, one in ascending order and one
in descending order, so when inserting and item is required we will pop the
items from the list with descending order into the list with ascending order
allowing consistency and speed across movements.


This is an example interaction using the insertion sort algorithm


|&|: is the return block, anything below it points to the final return
value of the function
|X|: is a block that represents an item which value is X (a constant value)
|-|: is a block that represents a list
(L): is the name of the list, is shown only to ease the understanding of


The user will start by moving the top item of L into DSC, in erlang code:

isort([TopL|RestL], [], []) -> isort(RestL, [TopL], []);

State 1:
|5|
|3|
|1|
|4|
|2|
|-|  |-|   |-|
(L) (DSC) (ASC)


After this he will pass the items from L into DSC until the top element of L is
greater than the top element of DSC, in erlang code:

isort([TopL|RestL], [TopDSC|RestDSC], []) when TopL < TopDSC -> isort(RestL, [TopL|TopDSC|RestDSC], []);

State 2:
|3|
|1|
|4|
|2|  |5|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 3:
|1|
|4|  |3|
|2|  |5|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 4:
     |1|
|4|  |3|
|2|  |5|
|-|  |-|   |-|
(L) (DSC) (ASC)


If this condition is true, the user will move the elements that are greater than
the top element in L from DSC into ASC, in erlang code:

isort([TopL|RestL], [TopDSC|RestDSC], []) when TopL > TopDSC -> isort([TopL|RestL], RestDSC, [TopDSC]);

for state 5, and:

isort([TopL|RestL], [TopDSC|RestDSC], [TopASC|RestASC]) when TopL > TopDSC -> isort([TopL|RestL], RestDSC, [TopDSC|[TopASC|RestASC]]);

for state 6

State 5:
|4|  |3|
|2|  |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 6:
|4|        |3|
|2|  |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

The next step is to move all the items from ASC that are lower than the top
element of L back into DSC, in erlang code:

isort([TopL|RestL], [TopDSC|RestDSC], [TopASC|RestASC]) when TopL < TopASC -> isort([TopL|RestL], [TopASC|TopDSC|RestDSC], RestASC);

State 7:
     |4|   |3|
|2|  |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 8:
     |3|
     |4|
|2|  |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

This process has to be repeated until L is empty, in erlang code:

isort([TopL|RestL], [TopDSC|RestDSC], [TopASC|RestASC]) when TopL > TopASC -> isort(RestL, [TopL|TopDSC|RestDSC], [TopASC|RestASC]);

State 9:
     |2|
     |3|
     |4|
     |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

When L is empty the final step is to move the items from DSC on top of the items
of ASC, in erlang code:

isort([], [TopDSC|RestDSC], [TopASC|RestASC]) when TopL < TopASC -> isort([], RestDSC, [TopDSC|TopASC|RestASC]);

State 10:
     |3|
     |4|   |2|
     |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 11:
           |3|
     |4|   |2|
     |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 12:
           |4|
           |3|
           |2|
     |5|   |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

State 13:
           |5|
           |4|
           |3|
           |2|
           |1|
|-|  |-|   |-|
(L) (DSC) (ASC)

Finally, the solution will be in the list ASC, in erlang code:

isort([], [], ASC) -> ASC.

State 13:
           |&|
           |5|
           |4|
           |3|
           |2|
           |1|
|-|  |-|   |-|
(L) (DSC) (ASC)


After analizing the code you can make a generalization of the state 1, this step
is missing in the given example but is part of the general view of insertion
sort, the user will eventually figure it out after doing more exercises of the
same problem, realizing that one statement was missing, in erlang code:

isort([TopL|RestL],[],[TopASC|RestASC]) -> isort(RestL,[TopL],[TopASC|RestASC]);
